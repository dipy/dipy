
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>DIPY &#8212; dipy 1.0.0 documentation</title>
    <link rel="stylesheet" href="../_static/dipy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="boots" href="dipy.boots.html" />
    <link rel="prev" title="__config__" href="dipy.__config__.html" />
  <meta name="keywords" content="DIPY, dMRI, DTI, DSI, diffusion MRI, Tensor,
  neuroimaging, python, neuroscience, Eleftherios, Garyfallidis, tractography,
  streamlines, fiber tracking">

  </head><body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <a href="../index.html">
  <img src="../_static/dipy-banner.png" alt="DIPY logo"  border="0" />
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dipy.boots.html" title="boots"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dipy.__config__.html" title="__config__"
             accesskey="P">previous</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">API Reference</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">


<h4> Site Navigation </h4>
  <ul>
    <li><a href="../documentation.html">Documentation</a></li>
    <li><a href="../devel/index.html">Development</a></li>
  </ul>

<h4> NIPY Community </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://nipy.org/">Community Home</a></li>
    <li><a class="reference external"
	href="http://nipy.org/">NIPY Projects</a></li>
    <li><a class="reference external"
	href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing List</a></li>
    <li><a class="reference external"
	href="http://nipy.org/nipy/license.html">License</a></li>
  </ul>


  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">align</span></code></a><ul>
<li><a class="reference internal" href="#module-dipy.align.imaffine">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.imaffine</span></code></a><ul>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-dipy.align.imwarp">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.imwarp</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.align.metrics">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.metrics</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.align.reslice">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.reslice</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.align.scalespace">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.scalespace</span></code></a></li>
<li><a class="reference internal" href="#module-dipy.align.streamlinear">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.streamlinear</span></code></a><ul>
<li><a class="reference internal" href="#bunch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bunch</span></code></a></li>
<li><a class="reference internal" href="#floating"><code class="xref py py-class docutils literal notranslate"><span class="pre">floating</span></code></a></li>
<li><a class="reference internal" href="#affineinvalidvalueserror"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineInvalidValuesError</span></code></a></li>
<li><a class="reference internal" href="#affineinversionerror"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineInversionError</span></code></a></li>
<li><a class="reference internal" href="#affinemap"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineMap</span></code></a></li>
<li><a class="reference internal" href="#affineregistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineRegistration</span></code></a></li>
<li><a class="reference internal" href="#isotropicscalespace"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicScaleSpace</span></code></a></li>
<li><a class="reference internal" href="#mutualinformationmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutualInformationMetric</span></code></a></li>
<li><a class="reference internal" href="#optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Optimizer</span></code></a></li>
<li><a class="reference internal" href="#parzenjointhistogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParzenJointHistogram</span></code></a></li>
<li><a class="reference internal" href="#scalespace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a></li>
<li><a class="reference internal" href="#compute-parzen-mi">compute_parzen_mi</a></li>
<li><a class="reference internal" href="#get-direction-and-spacings">get_direction_and_spacings</a></li>
<li><a class="reference internal" href="#interpolate-scalar-2d">interpolate_scalar_2d</a></li>
<li><a class="reference internal" href="#interpolate-scalar-3d">interpolate_scalar_3d</a></li>
<li><a class="reference internal" href="#sample-domain-regular">sample_domain_regular</a></li>
<li><a class="reference internal" href="#transform-centers-of-mass">transform_centers_of_mass</a></li>
<li><a class="reference internal" href="#transform-geometric-centers">transform_geometric_centers</a></li>
<li><a class="reference internal" href="#transform-origins">transform_origins</a></li>
<li><a class="reference internal" href="#warn">warn</a></li>
<li><a class="reference internal" href="#id1"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bunch</span></code></a></li>
<li><a class="reference internal" href="#diffeomorphicmap"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffeomorphicMap</span></code></a></li>
<li><a class="reference internal" href="#diffeomorphicregistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffeomorphicRegistration</span></code></a></li>
<li><a class="reference internal" href="#id2"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a></li>
<li><a class="reference internal" href="#symmetricdiffeomorphicregistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration</span></code></a></li>
<li><a class="reference internal" href="#id3"><code class="xref py py-class docutils literal notranslate"><span class="pre">floating</span></code></a></li>
<li><a class="reference internal" href="#id4">get_direction_and_spacings</a></li>
<li><a class="reference internal" href="#mult-aff">mult_aff</a></li>
<li><a class="reference internal" href="#ccmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">CCMetric</span></code></a></li>
<li><a class="reference internal" href="#emmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">EMMetric</span></code></a></li>
<li><a class="reference internal" href="#ssdmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSDMetric</span></code></a></li>
<li><a class="reference internal" href="#similaritymetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityMetric</span></code></a></li>
<li><a class="reference internal" href="#id5"><code class="xref py py-class docutils literal notranslate"><span class="pre">floating</span></code></a></li>
<li><a class="reference internal" href="#gradient">gradient</a></li>
<li><a class="reference internal" href="#v-cycle-2d">v_cycle_2d</a></li>
<li><a class="reference internal" href="#v-cycle-3d">v_cycle_3d</a></li>
<li><a class="reference internal" href="#pool">Pool</a></li>
<li><a class="reference internal" href="#affine-transform">affine_transform</a></li>
<li><a class="reference internal" href="#cpu-count">cpu_count</a></li>
<li><a class="reference internal" href="#reslice">reslice</a></li>
<li><a class="reference internal" href="#id11"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicScaleSpace</span></code></a></li>
<li><a class="reference internal" href="#id12"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a></li>
<li><a class="reference internal" href="#id13"><code class="xref py py-class docutils literal notranslate"><span class="pre">floating</span></code></a></li>
<li><a class="reference internal" href="#bundlemindistanceasymmetricmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric</span></code></a></li>
<li><a class="reference internal" href="#bundlemindistancematrixmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric</span></code></a></li>
<li><a class="reference internal" href="#bundlemindistancemetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a></li>
<li><a class="reference internal" href="#bundlesumdistancematrixmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric</span></code></a></li>
<li><a class="reference internal" href="#id15"><code class="xref py py-class docutils literal notranslate"><span class="pre">Optimizer</span></code></a></li>
<li><a class="reference internal" href="#streamlinedistancemetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineDistanceMetric</span></code></a></li>
<li><a class="reference internal" href="#streamlinelinearregistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineLinearRegistration</span></code></a></li>
<li><a class="reference internal" href="#streamlineregistrationmap"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineRegistrationMap</span></code></a></li>
<li><a class="reference internal" href="#streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Streamlines</span></code></a></li>
<li><a class="reference internal" href="#bundle-min-distance">bundle_min_distance</a></li>
<li><a class="reference internal" href="#bundle-min-distance-asymmetric-fast">bundle_min_distance_asymmetric_fast</a></li>
<li><a class="reference internal" href="#bundle-min-distance-fast">bundle_min_distance_fast</a></li>
<li><a class="reference internal" href="#bundle-sum-distance">bundle_sum_distance</a></li>
<li><a class="reference internal" href="#center-streamlines">center_streamlines</a></li>
<li><a class="reference internal" href="#compose-matrix">compose_matrix</a></li>
<li><a class="reference internal" href="#compose-matrix44">compose_matrix44</a></li>
<li><a class="reference internal" href="#compose-transformations">compose_transformations</a></li>
<li><a class="reference internal" href="#decompose-matrix">decompose_matrix</a></li>
<li><a class="reference internal" href="#decompose-matrix44">decompose_matrix44</a></li>
<li><a class="reference internal" href="#distance-matrix-mdf">distance_matrix_mdf</a></li>
<li><a class="reference internal" href="#length">length</a></li>
<li><a class="reference internal" href="#progressive-slr">progressive_slr</a></li>
<li><a class="reference internal" href="#qbx-and-merge">qbx_and_merge</a></li>
<li><a class="reference internal" href="#remove-clusters-by-size">remove_clusters_by_size</a></li>
<li><a class="reference internal" href="#select-random-set-of-streamlines">select_random_set_of_streamlines</a></li>
<li><a class="reference internal" href="#set-number-of-points">set_number_of_points</a></li>
<li><a class="reference internal" href="#slr-with-qbx">slr_with_qbx</a></li>
<li><a class="reference internal" href="#time">time</a></li>
<li><a class="reference internal" href="#transform-streamlines">transform_streamlines</a></li>
<li><a class="reference internal" href="#unlist-streamlines">unlist_streamlines</a></li>
<li><a class="reference internal" href="#whole-brain-slr">whole_brain_slr</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dipy.__config__.html"
                        title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__config__</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dipy.boots.html"
                        title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">boots</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/dipy.align.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dipy.align">
<span id="align"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">align</span></code><a class="headerlink" href="#module-dipy.align" title="Permalink to this headline">¶</a></h1>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.Bunch" title="dipy.align.Bunch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Bunch</span></code></a>(**kwds)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.floating" title="dipy.align.floating"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floating</span></code></a></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float32</span></code></p></td>
</tr>
</tbody>
</table>
<div class="section" id="module-dipy.align.imaffine">
<span id="module-align-imaffine"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.imaffine</span></code><a class="headerlink" href="#module-dipy.align.imaffine" title="Permalink to this headline">¶</a></h2>
<p>Affine image registration module consisting of the following classes:</p>
<dl class="simple">
<dt>AffineMap: encapsulates the necessary information to perform affine</dt><dd><p>transforms between two domains, defined by a <cite>static</cite> and a <cite>moving</cite>
image. The <cite>domain</cite> of the transform is the set of points in the
<cite>static</cite> image’s grid, and the <cite>codomain</cite> is the set of points in
the <cite>moving</cite> image. When we call the <cite>transform</cite> method, <cite>AffineMap</cite>
maps each point <cite>x</cite> of the domain (<cite>static</cite> grid) to the codomain
(<cite>moving</cite> grid) and interpolates the <cite>moving</cite> image at that point
to obtain the intensity value to be placed at <cite>x</cite> in the resulting
grid. The <cite>transform_inverse</cite> method performs the opposite operation
mapping points in the codomain to points in the domain.</p>
</dd>
<dt>ParzenJointHistogram: computes the marginal and joint distributions of</dt><dd><p>intensities of a pair of images, using Parzen windows [Parzen62]
with a cubic spline kernel, as proposed by Mattes et al. [Mattes03].
It also computes the gradient of the joint histogram w.r.t. the
parameters of a given transform.</p>
</dd>
<dt>MutualInformationMetric: computes the value and gradient of the mutual</dt><dd><p>information metric the way <cite>Optimizer</cite> needs them. That is, given
a set of transform parameters, it will use <cite>ParzenJointHistogram</cite>
to compute the value and gradient of the joint intensity histogram
evaluated at the given parameters, and evaluate the the value and
gradient of the histogram’s mutual information.</p>
</dd>
<dt>AffineRegistration: it runs the multi-resolution registration, putting</dt><dd><p>all the pieces together. It needs to create the scale space of the
images and run the multi-resolution registration by using the Metric
and the Optimizer at each level of the Gaussian pyramid. At each
level, it will setup the metric to compute value and gradient of the
metric with the input images with different levels of smoothing.</p>
</dd>
</dl>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>[Parzen62] E. Parzen. On the estimation of a probability density</dt><dd><p>function and the mode. Annals of Mathematical Statistics,
33(3), 1065-1076, 1962.</p>
</dd>
<dt>[Mattes03] Mattes, D., Haynor, D. R., Vesselle, H., Lewellen, T. K.,</dt><dd><p>&amp; Eubank, W. PET-CT image registration in the chest using
free-form deformations. IEEE Transactions on Medical
Imaging, 22(1), 120-8, 2003.</p>
</dd>
</dl>
</div>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineInvalidValuesError" title="dipy.align.imaffine.AffineInvalidValuesError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineInvalidValuesError</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineInversionError" title="dipy.align.imaffine.AffineInversionError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineInversionError</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineMap" title="dipy.align.imaffine.AffineMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineMap</span></code></a>(affine[, domain_grid_shape, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineRegistration" title="dipy.align.imaffine.AffineRegistration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineRegistration</span></code></a>([metric, level_iters, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.IsotropicScaleSpace" title="dipy.align.imaffine.IsotropicScaleSpace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsotropicScaleSpace</span></code></a>(image, factors, sigmas)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.MutualInformationMetric" title="dipy.align.imaffine.MutualInformationMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MutualInformationMetric</span></code></a>([nbins, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.Optimizer" title="dipy.align.imaffine.Optimizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Optimizer</span></code></a>(fun, x0[, args, method, jac, …])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.ParzenJointHistogram" title="dipy.align.imaffine.ParzenJointHistogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ParzenJointHistogram</span></code></a></p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace" title="dipy.align.imaffine.ScaleSpace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a>(image, num_levels[, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.compute_parzen_mi" title="dipy.align.imaffine.compute_parzen_mi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_parzen_mi</span></code></a></p></td>
<td><p>Computes the mutual information and its gradient (if requested)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.get_direction_and_spacings" title="dipy.align.imaffine.get_direction_and_spacings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_direction_and_spacings</span></code></a>(affine, dim)</p></td>
<td><p>Extracts the rotational and spacing components from a matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.interpolate_scalar_2d" title="dipy.align.imaffine.interpolate_scalar_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_scalar_2d</span></code></a></p></td>
<td><p>Bilinear interpolation of a 2D scalar image</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.interpolate_scalar_3d" title="dipy.align.imaffine.interpolate_scalar_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_scalar_3d</span></code></a></p></td>
<td><p>Trilinear interpolation of a 3D scalar image</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.sample_domain_regular" title="dipy.align.imaffine.sample_domain_regular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_domain_regular</span></code></a></p></td>
<td><p>Take floor(total_voxels/k) samples from a (2D or 3D) grid</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.transform_centers_of_mass" title="dipy.align.imaffine.transform_centers_of_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_centers_of_mass</span></code></a>(static, …)</p></td>
<td><p>Transformation to align the center of mass of the input images.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.transform_geometric_centers" title="dipy.align.imaffine.transform_geometric_centers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_geometric_centers</span></code></a>(static, …)</p></td>
<td><p>Transformation to align the geometric center of the input images.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.transform_origins" title="dipy.align.imaffine.transform_origins"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_origins</span></code></a>(static, static_grid2world, …)</p></td>
<td><p>Transformation to align the origins of the input images.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.warn" title="dipy.align.imaffine.warn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warn</span></code></a></p></td>
<td><p>Issue a warning, or maybe ignore it or raise an exception.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.align.imwarp">
<span id="module-align-imwarp"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.imwarp</span></code><a class="headerlink" href="#module-dipy.align.imwarp" title="Permalink to this headline">¶</a></h2>
<p>Classes and functions for Symmetric Diffeomorphic Registration</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.Bunch" title="dipy.align.imwarp.Bunch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Bunch</span></code></a>(**kwds)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap" title="dipy.align.imwarp.DiffeomorphicMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffeomorphicMap</span></code></a>(dim, disp_shape[, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicRegistration" title="dipy.align.imwarp.DiffeomorphicRegistration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DiffeomorphicRegistration</span></code></a>([metric])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace" title="dipy.align.imwarp.ScaleSpace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a>(image, num_levels[, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration" title="dipy.align.imwarp.SymmetricDiffeomorphicRegistration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration</span></code></a>(metric[, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.floating" title="dipy.align.imwarp.floating"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floating</span></code></a></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float32</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.get_direction_and_spacings" title="dipy.align.imwarp.get_direction_and_spacings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_direction_and_spacings</span></code></a>(affine, dim)</p></td>
<td><p>Extracts the rotational and spacing components from a matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.mult_aff" title="dipy.align.imwarp.mult_aff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mult_aff</span></code></a>(A, B)</p></td>
<td><p>Returns the matrix product A.dot(B) considering None as the identity</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.align.metrics">
<span id="module-align-metrics"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.metrics</span></code><a class="headerlink" href="#module-dipy.align.metrics" title="Permalink to this headline">¶</a></h2>
<p>Metrics for Symmetric Diffeomorphic Registration</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.CCMetric" title="dipy.align.metrics.CCMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CCMetric</span></code></a>(dim[, sigma_diff, radius])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric" title="dipy.align.metrics.EMMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EMMetric</span></code></a>(dim[, smooth, inner_iter, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SSDMetric" title="dipy.align.metrics.SSDMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SSDMetric</span></code></a>(dim[, smooth, inner_iter, step_type])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric" title="dipy.align.metrics.SimilarityMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SimilarityMetric</span></code></a>(dim)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.floating" title="dipy.align.metrics.floating"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floating</span></code></a></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float32</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.gradient" title="dipy.align.metrics.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a>(f, *varargs, **kwargs)</p></td>
<td><p>Return the gradient of an N-dimensional array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.v_cycle_2d" title="dipy.align.metrics.v_cycle_2d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">v_cycle_2d</span></code></a>(n, k, delta_field, …[, depth])</p></td>
<td><p>Multi-resolution Gauss-Seidel solver using V-type cycles</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.v_cycle_3d" title="dipy.align.metrics.v_cycle_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">v_cycle_3d</span></code></a>(n, k, delta_field, …[, depth])</p></td>
<td><p>Multi-resolution Gauss-Seidel solver using V-type cycles</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.align.reslice">
<span id="module-align-reslice"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.reslice</span></code><a class="headerlink" href="#module-dipy.align.reslice" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.reslice.Pool" title="dipy.align.reslice.Pool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Pool</span></code></a>([processes, initializer, initargs, …])</p></td>
<td><p>Returns a process pool object</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.reslice.affine_transform" title="dipy.align.reslice.affine_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">affine_transform</span></code></a>(input, matrix[, offset, …])</p></td>
<td><p>Apply an affine transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.reslice.cpu_count" title="dipy.align.reslice.cpu_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cpu_count</span></code></a>()</p></td>
<td><p>Returns the number of CPUs in the system</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.reslice.reslice" title="dipy.align.reslice.reslice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reslice</span></code></a>(data, affine, zooms, new_zooms[, …])</p></td>
<td><p>Reslice data with new voxel resolution defined by <code class="docutils literal notranslate"><span class="pre">new_zooms</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.align.scalespace">
<span id="module-align-scalespace"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.scalespace</span></code><a class="headerlink" href="#module-dipy.align.scalespace" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.scalespace.IsotropicScaleSpace" title="dipy.align.scalespace.IsotropicScaleSpace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsotropicScaleSpace</span></code></a>(image, factors, sigmas)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace" title="dipy.align.scalespace.ScaleSpace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a>(image, num_levels[, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.scalespace.floating" title="dipy.align.scalespace.floating"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floating</span></code></a></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float32</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-dipy.align.streamlinear">
<span id="module-align-streamlinear"></span><h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">align.streamlinear</span></code><a class="headerlink" href="#module-dipy.align.streamlinear" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric" title="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric</span></code></a>([num_threads])</p></td>
<td><p>Asymmetric Bundle-based Minimum distance</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric" title="dipy.align.streamlinear.BundleMinDistanceMatrixMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric</span></code></a>([num_threads])</p></td>
<td><p>Bundle-based Minimum Distance aka BMD</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMetric" title="dipy.align.streamlinear.BundleMinDistanceMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a>([num_threads])</p></td>
<td><p>Bundle-based Minimum Distance aka BMD</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric" title="dipy.align.streamlinear.BundleSumDistanceMatrixMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric</span></code></a>([num_threads])</p></td>
<td><p>Bundle-based Sum Distance aka BMD</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.Optimizer" title="dipy.align.streamlinear.Optimizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Optimizer</span></code></a>(fun, x0[, args, method, jac, …])</p></td>
<td><p><dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="dipy.align.streamlinear.StreamlineDistanceMetric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StreamlineDistanceMetric</span></code></a>([num_threads])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.StreamlineLinearRegistration" title="dipy.align.streamlinear.StreamlineLinearRegistration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StreamlineLinearRegistration</span></code></a>([metric, x0, …])</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.StreamlineRegistrationMap" title="dipy.align.streamlinear.StreamlineRegistrationMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StreamlineRegistrationMap</span></code></a>(matopt, xopt, …)</p></td>
<td><p><p class="rubric">Methods</p>
</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.Streamlines" title="dipy.align.streamlinear.Streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Streamlines</span></code></a></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.array_sequence.ArraySequence</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.bundle_min_distance" title="dipy.align.streamlinear.bundle_min_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundle_min_distance</span></code></a>(t, static, moving)</p></td>
<td><p>MDF-based pairwise distance optimization function (MIN)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.bundle_min_distance_asymmetric_fast" title="dipy.align.streamlinear.bundle_min_distance_asymmetric_fast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundle_min_distance_asymmetric_fast</span></code></a>(t, …)</p></td>
<td><p>MDF-based pairwise distance optimization function (MIN)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.bundle_min_distance_fast" title="dipy.align.streamlinear.bundle_min_distance_fast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundle_min_distance_fast</span></code></a>(t, static, moving, …)</p></td>
<td><p>MDF-based pairwise distance optimization function (MIN)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.bundle_sum_distance" title="dipy.align.streamlinear.bundle_sum_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bundle_sum_distance</span></code></a>(t, static, moving[, …])</p></td>
<td><p>MDF distance optimization function (SUM)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.center_streamlines" title="dipy.align.streamlinear.center_streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_streamlines</span></code></a>(streamlines)</p></td>
<td><p>Move streamlines to the origin</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.compose_matrix" title="dipy.align.streamlinear.compose_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose_matrix</span></code></a>([scale, shear, angles, …])</p></td>
<td><p>Return 4x4 transformation matrix from sequence of transformations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.compose_matrix44" title="dipy.align.streamlinear.compose_matrix44"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose_matrix44</span></code></a>(t[, dtype])</p></td>
<td><p>Compose a 4x4 transformation matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.compose_transformations" title="dipy.align.streamlinear.compose_transformations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose_transformations</span></code></a>(*mats)</p></td>
<td><p>Compose multiple 4x4 affine transformations in one 4x4 matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.decompose_matrix" title="dipy.align.streamlinear.decompose_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_matrix</span></code></a>(matrix)</p></td>
<td><p>Return sequence of transformations from transformation matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.decompose_matrix44" title="dipy.align.streamlinear.decompose_matrix44"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decompose_matrix44</span></code></a>(mat[, size])</p></td>
<td><p>Given a 4x4 homogeneous matrix return the parameter vector</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.distance_matrix_mdf" title="dipy.align.streamlinear.distance_matrix_mdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance_matrix_mdf</span></code></a></p></td>
<td><p>Minimum direct flipped distance matrix between two streamline sets</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.length" title="dipy.align.streamlinear.length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">length</span></code></a></p></td>
<td><p>Euclidean length of streamlines</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.progressive_slr" title="dipy.align.streamlinear.progressive_slr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">progressive_slr</span></code></a>(static, moving, metric, x0, …)</p></td>
<td><p>Progressive SLR</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.qbx_and_merge" title="dipy.align.streamlinear.qbx_and_merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qbx_and_merge</span></code></a>(streamlines, thresholds[, …])</p></td>
<td><p>Run QuickBundlesX and then run again on the centroids of the last layer</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.remove_clusters_by_size" title="dipy.align.streamlinear.remove_clusters_by_size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_clusters_by_size</span></code></a>(clusters[, min_size])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.select_random_set_of_streamlines" title="dipy.align.streamlinear.select_random_set_of_streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_random_set_of_streamlines</span></code></a>(…[, rng])</p></td>
<td><p>Select a random set of streamlines</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.set_number_of_points" title="dipy.align.streamlinear.set_number_of_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_number_of_points</span></code></a></p></td>
<td><p>Change the number of points of streamlines</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.slr_with_qbx" title="dipy.align.streamlinear.slr_with_qbx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slr_with_qbx</span></code></a>(static, moving[, x0, …])</p></td>
<td><p>Utility function for registering large tractograms.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.time" title="dipy.align.streamlinear.time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time</span></code></a>()</p></td>
<td><p>Return the current time in seconds since the Epoch.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.transform_streamlines" title="dipy.align.streamlinear.transform_streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_streamlines</span></code></a>(streamlines, mat[, …])</p></td>
<td><p>Apply affine transformation to streamlines</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.streamlinear.unlist_streamlines" title="dipy.align.streamlinear.unlist_streamlines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unlist_streamlines</span></code></a>(streamlines)</p></td>
<td><p>Return the streamlines not as a list but as an array and an offset</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.whole_brain_slr" title="dipy.align.streamlinear.whole_brain_slr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">whole_brain_slr</span></code></a>(static, moving[, x0, …])</p></td>
<td><p>Utility function for registering large tractograms.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="bunch">
<h3><a class="reference internal" href="#dipy.align.Bunch" title="dipy.align.Bunch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bunch</span></code></a><a class="headerlink" href="#bunch" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.Bunch">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.</code><code class="sig-name descname">Bunch</code><span class="sig-paren">(</span><em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.Bunch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="method">
<dt id="dipy.align.Bunch.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.Bunch.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A ‘bunch’ of values (a replacement of Enum)</p>
<p>This is a temporary replacement of Enum, which is not available
on all versions of Python 2</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="floating">
<h3><a class="reference internal" href="#dipy.align.floating" title="dipy.align.floating"><code class="xref py py-class docutils literal notranslate"><span class="pre">floating</span></code></a><a class="headerlink" href="#floating" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.align.floating">
<code class="sig-prename descclassname">dipy.align.</code><code class="sig-name descname">floating</code><a class="headerlink" href="#dipy.align.floating" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float32</span></code></p>
</dd></dl>

</div>
<div class="section" id="affineinvalidvalueserror">
<h3><a class="reference internal" href="#dipy.align.imaffine.AffineInvalidValuesError" title="dipy.align.imaffine.AffineInvalidValuesError"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineInvalidValuesError</span></code></a><a class="headerlink" href="#affineinvalidvalueserror" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imaffine.AffineInvalidValuesError">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">AffineInvalidValuesError</code><a class="headerlink" href="#dipy.align.imaffine.AffineInvalidValuesError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">with_traceback</span></code></p></td>
<td><p>Exception.with_traceback(tb) – set self.__traceback__ to tb and return self.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imaffine.AffineInvalidValuesError.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineInvalidValuesError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="affineinversionerror">
<h3><a class="reference internal" href="#dipy.align.imaffine.AffineInversionError" title="dipy.align.imaffine.AffineInversionError"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineInversionError</span></code></a><a class="headerlink" href="#affineinversionerror" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imaffine.AffineInversionError">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">AffineInversionError</code><a class="headerlink" href="#dipy.align.imaffine.AffineInversionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">with_traceback</span></code></p></td>
<td><p>Exception.with_traceback(tb) – set self.__traceback__ to tb and return self.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imaffine.AffineInversionError.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">$self</em>, <em class="sig-param">/</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineInversionError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="affinemap">
<h3><a class="reference internal" href="#dipy.align.imaffine.AffineMap" title="dipy.align.imaffine.AffineMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineMap</span></code></a><a class="headerlink" href="#affinemap" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imaffine.AffineMap">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">AffineMap</code><span class="sig-paren">(</span><em class="sig-param">affine</em>, <em class="sig-param">domain_grid_shape=None</em>, <em class="sig-param">domain_grid2world=None</em>, <em class="sig-param">codomain_grid_shape=None</em>, <em class="sig-param">codomain_grid2world=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineMap.get_affine" title="dipy.align.imaffine.AffineMap.get_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine</span></code></a>()</p></td>
<td><p>Return the value of the transformation, not a reference.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineMap.set_affine" title="dipy.align.imaffine.AffineMap.set_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_affine</span></code></a>(affine)</p></td>
<td><p>Set the affine transform (operating in physical space).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineMap.transform" title="dipy.align.imaffine.AffineMap.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(image[, interp, image_grid2world, …])</p></td>
<td><p>Transform the input image from co-domain to domain space.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineMap.transform_inverse" title="dipy.align.imaffine.AffineMap.transform_inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_inverse</span></code></a>(image[, interp, …])</p></td>
<td><p>Transform the input image from domain to co-domain space.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imaffine.AffineMap.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">affine</em>, <em class="sig-param">domain_grid_shape=None</em>, <em class="sig-param">domain_grid2world=None</em>, <em class="sig-param">codomain_grid_shape=None</em>, <em class="sig-param">codomain_grid2world=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>AffineMap</p>
<p>Implements an affine transformation whose domain is given by
<cite>domain_grid</cite> and <cite>domain_grid2world</cite>, and whose co-domain is
given by <cite>codomain_grid</cite> and <cite>codomain_grid2world</cite>.</p>
<p>The actual transform is represented by the <cite>affine</cite> matrix, which
operate in world coordinates. Therefore, to transform a moving image
towards a static image, we first map each voxel (i,j,k) of the static
image to world coordinates (x,y,z) by applying <cite>domain_grid2world</cite>.
Then we apply the <cite>affine</cite> transform to (x,y,z) obtaining (x’, y’, z’)
in moving image’s world coordinates. Finally, (x’, y’, z’) is mapped
to voxel coordinates (i’, j’, k’) in the moving image by multiplying
(x’, y’, z’) by the inverse of <cite>codomain_grid2world</cite>. The
<cite>codomain_grid_shape</cite> is used analogously to transform the static
image towards the moving image when calling <cite>transform_inverse</cite>.</p>
<p>If the domain/co-domain information is not provided (None) then the
sampling information needs to be specified each time the <cite>transform</cite>
or <cite>transform_inverse</cite> is called to transform images. Note that such
sampling information is not necessary to transform points defined in
physical space, such as stream lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">array, shape (dim + 1, dim + 1)</span></dt><dd><p>the matrix defining the affine transform, where <cite>dim</cite> is the
dimension of the space this map operates in (2 for 2D images,
3 for 3D images). If None, then <cite>self</cite> represents the identity
transformation.</p>
</dd>
<dt><strong>domain_grid_shape</strong><span class="classifier">sequence, shape (dim,), optional</span></dt><dd><p>the shape of the default domain sampling grid. When <cite>transform</cite>
is called to transform an image, the resulting image will have
this shape, unless a different sampling information is provided.
If None, then the sampling grid shape must be specified each time
the <cite>transform</cite> method is called.</p>
</dd>
<dt><strong>domain_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-world transform associated with the domain grid.
If None (the default), then the grid-to-world transform is assumed
to be the identity.</p>
</dd>
<dt><strong>codomain_grid_shape</strong><span class="classifier">sequence of integers, shape (dim,)</span></dt><dd><p>the shape of the default co-domain sampling grid. When
<cite>transform_inverse</cite> is called to transform an image, the resulting
image will have this shape, unless a different sampling
information is provided. If None (the default), then the sampling
grid shape must be specified each time the <cite>transform_inverse</cite>
method is called.</p>
</dd>
<dt><strong>codomain_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1)</span></dt><dd><p>the grid-to-world transform associated with the co-domain grid.
If None (the default), then the grid-to-world transform is assumed
to be the identity.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.AffineMap.get_affine">
<code class="sig-name descname">get_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the transformation, not a reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">ndarray</span></dt><dd><p>Copy of the transform, not a reference.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.AffineMap.set_affine">
<code class="sig-name descname">set_affine</code><span class="sig-paren">(</span><em class="sig-param">affine</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap.set_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the affine transform (operating in physical space).</p>
<p>Also sets <cite>self.affine_inv</cite> - the inverse of <cite>affine</cite>, or None if
there is no inverse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">array, shape (dim + 1, dim + 1)</span></dt><dd><p>the matrix representing the affine transform operating in
physical space. The domain and co-domain information
remains unchanged. If None, then <cite>self</cite> represents the identity
transformation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.AffineMap.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">interp='linear'</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">sampling_grid_shape=None</em>, <em class="sig-param">sampling_grid2world=None</em>, <em class="sig-param">resample_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the input image from co-domain to domain space.</p>
<p>By default, the transformed image is sampled at a grid defined by
<cite>self.domain_shape</cite> and <cite>self.domain_grid2world</cite>. If such
information was not provided then <cite>sampling_grid_shape</cite> is mandatory.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2D or 3D array</span></dt><dd><p>the image to be transformed</p>
</dd>
<dt><strong>interp</strong><span class="classifier">string, either ‘linear’ or ‘nearest’</span></dt><dd><p>the type of interpolation to be used, either ‘linear’
(for k-linear interpolation) or ‘nearest’ for nearest neighbor</p>
</dd>
<dt><strong>image_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-world transform associated with <cite>image</cite>.
If None (the default), then the grid-to-world transform is assumed
to be the identity.</p>
</dd>
<dt><strong>sampling_grid_shape</strong><span class="classifier">sequence, shape (dim,), optional</span></dt><dd><p>the shape of the grid where the transformed image must be sampled.
If None (the default), then <cite>self.codomain_shape</cite> is used instead
(which must have been set at initialization, otherwise an exception
will be raised).</p>
</dd>
<dt><strong>sampling_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-world transform associated with the sampling grid
(specified by <cite>sampling_grid_shape</cite>, or by default
<cite>self.codomain_shape</cite>). If None (the default), then the
grid-to-world transform is assumed to be the identity.</p>
</dd>
<dt><strong>resample_only</strong><span class="classifier">Boolean, optional</span></dt><dd><p>If False (the default) the affine transform is applied normally.
If True, then the affine transform is not applied, and the input
image is just re-sampled on the domain grid of this transform.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>transformed</strong><span class="classifier">array, shape <cite>sampling_grid_shape</cite> or</span></dt><dd><blockquote>
<div><p><cite>self.codomain_shape</cite></p>
</div></blockquote>
<p>the transformed image, sampled at the requested grid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.AffineMap.transform_inverse">
<code class="sig-name descname">transform_inverse</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">interp='linear'</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">sampling_grid_shape=None</em>, <em class="sig-param">sampling_grid2world=None</em>, <em class="sig-param">resample_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineMap.transform_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the input image from domain to co-domain space.</p>
<p>By default, the transformed image is sampled at a grid defined by
<cite>self.codomain_shape</cite> and <cite>self.codomain_grid2world</cite>. If such
information was not provided then <cite>sampling_grid_shape</cite> is mandatory.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2D or 3D array</span></dt><dd><p>the image to be transformed</p>
</dd>
<dt><strong>interp</strong><span class="classifier">string, either ‘linear’ or ‘nearest’</span></dt><dd><p>the type of interpolation to be used, either ‘linear’
(for k-linear interpolation) or ‘nearest’ for nearest neighbor</p>
</dd>
<dt><strong>image_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-world transform associated with <cite>image</cite>.
If None (the default), then the grid-to-world transform is assumed
to be the identity.</p>
</dd>
<dt><strong>sampling_grid_shape</strong><span class="classifier">sequence, shape (dim,), optional</span></dt><dd><p>the shape of the grid where the transformed image must be sampled.
If None (the default), then <cite>self.codomain_shape</cite> is used instead
(which must have been set at initialization, otherwise an exception
will be raised).</p>
</dd>
<dt><strong>sampling_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-world transform associated with the sampling grid
(specified by <cite>sampling_grid_shape</cite>, or by default
<cite>self.codomain_shape</cite>). If None (the default), then the
grid-to-world transform is assumed to be the identity.</p>
</dd>
<dt><strong>resample_only</strong><span class="classifier">Boolean, optional</span></dt><dd><p>If False (the default) the affine transform is applied normally.
If True, then the affine transform is not applied, and the input
image is just re-sampled on the domain grid of this transform.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>transformed</strong><span class="classifier">array, shape <cite>sampling_grid_shape</cite> or</span></dt><dd><blockquote>
<div><p><cite>self.codomain_shape</cite></p>
</div></blockquote>
<p>the transformed image, sampled at the requested grid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="affineregistration">
<h3><a class="reference internal" href="#dipy.align.imaffine.AffineRegistration" title="dipy.align.imaffine.AffineRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineRegistration</span></code></a><a class="headerlink" href="#affineregistration" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imaffine.AffineRegistration">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">AffineRegistration</code><span class="sig-paren">(</span><em class="sig-param">metric=None</em>, <em class="sig-param">level_iters=None</em>, <em class="sig-param">sigmas=None</em>, <em class="sig-param">factors=None</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">ss_sigma_factor=None</em>, <em class="sig-param">options=None</em>, <em class="sig-param">verbosity=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineRegistration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.AffineRegistration.optimize" title="dipy.align.imaffine.AffineRegistration.optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize</span></code></a>(static, moving, transform, params0)</p></td>
<td><p>Start the optimization process.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imaffine.AffineRegistration.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">metric=None</em>, <em class="sig-param">level_iters=None</em>, <em class="sig-param">sigmas=None</em>, <em class="sig-param">factors=None</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">ss_sigma_factor=None</em>, <em class="sig-param">options=None</em>, <em class="sig-param">verbosity=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineRegistration.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an instance of the AffineRegistration class.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>metric</strong><span class="classifier">None or object, optional</span></dt><dd><p>an instance of a metric. The default is None, implying
the Mutual Information metric with default settings.</p>
</dd>
<dt><strong>level_iters</strong><span class="classifier">sequence, optional</span></dt><dd><p>the number of iterations at each scale of the scale space.
<cite>level_iters[0]</cite> corresponds to the coarsest scale,
<cite>level_iters[-1]</cite> the finest, where n is the length of the
sequence. By default, a 3-level scale space with iterations
sequence equal to [10000, 1000, 100] will be used.</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">sequence of floats, optional</span></dt><dd><p>custom smoothing parameter to build the scale space (one parameter
for each scale). By default, the sequence of sigmas will be
[3, 1, 0].</p>
</dd>
<dt><strong>factors</strong><span class="classifier">sequence of floats, optional</span></dt><dd><p>custom scale factors to build the scale space (one factor for each
scale). By default, the sequence of factors will be [4, 2, 1].</p>
</dd>
<dt><strong>method</strong><span class="classifier">string, optional</span></dt><dd><p>optimization method to be used. If Scipy version &lt; 0.12, then
only L-BFGS-B is available. Otherwise, <cite>method</cite> can be any
gradient-based method available in <cite>dipy.core.Optimize</cite>: CG, BFGS,
Newton-CG, dogleg or trust-ncg.
The default is ‘L-BFGS-B’.</p>
</dd>
<dt><strong>ss_sigma_factor</strong><span class="classifier">float, optional</span></dt><dd><p>If None, this parameter is not used and an isotropic scale
space with the given <cite>factors</cite> and <cite>sigmas</cite> will be built.
If not None, an anisotropic scale space will be used by
automatically selecting the smoothing sigmas along each axis
according to the voxel dimensions of the given image.
The <cite>ss_sigma_factor</cite> is used to scale the automatically computed
sigmas. For example, in the isotropic case, the sigma of the
kernel will be <span class="math notranslate nohighlight">\(factor * (2 ^ i)\)</span> where
<span class="math notranslate nohighlight">\(i = 1, 2, ..., n_scales - 1\)</span> is the scale (the finest resolution
image <span class="math notranslate nohighlight">\(i=0\)</span> is never smoothed). The default is None.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>extra optimization options. The default is None, implying
no extra options are passed to the optimizer.</p>
</dd>
<dt><strong>verbosity: int (one of {0, 1, 2, 3}), optional</strong></dt><dd><p>Set the verbosity level of the algorithm:
0 : do not print anything
1 : print information about the current status of the algorithm
2 : print high level information of the components involved in</p>
<blockquote>
<div><p>the registration that can be used to detect a failing
component.</p>
</div></blockquote>
<dl class="simple">
<dt>3<span class="classifier">print as much information as possible to isolate the cause</span></dt><dd><p>of a bug.</p>
</dd>
</dl>
<p>Default: 1</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.align.imaffine.AffineRegistration.docstring_addendum">
<code class="sig-name descname">docstring_addendum</code><em class="property"> = 'verbosity: int (one of {0, 1, 2, 3}), optional\n            Set the verbosity level of the algorithm:\n            0 : do not print anything\n            1 : print information about the current status of the algorithm\n            2 : print high level information of the components involved in\n                the registration that can be used to detect a failing\n                component.\n            3 : print as much information as possible to isolate the cause\n                of a bug.\n            Default: 1\n    '</em><a class="headerlink" href="#dipy.align.imaffine.AffineRegistration.docstring_addendum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.AffineRegistration.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">moving</em>, <em class="sig-param">transform</em>, <em class="sig-param">params0</em>, <em class="sig-param">static_grid2world=None</em>, <em class="sig-param">moving_grid2world=None</em>, <em class="sig-param">starting_affine=None</em>, <em class="sig-param">ret_metric=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.AffineRegistration.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the optimization process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>static</strong><span class="classifier">2D or 3D array</span></dt><dd><p>the image to be used as reference during optimization.</p>
</dd>
<dt><strong>moving</strong><span class="classifier">2D or 3D array</span></dt><dd><p>the image to be used as “moving” during optimization. It is
necessary to pre-align the moving image to ensure its domain
lies inside the domain of the deformation fields. This is assumed
to be accomplished by “pre-aligning” the moving image towards the
static using an affine transformation given by the
‘starting_affine’ matrix</p>
</dd>
<dt><strong>transform</strong><span class="classifier">instance of Transform</span></dt><dd><p>the transformation with respect to whose parameters the gradient
must be computed</p>
</dd>
<dt><strong>params0</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>parameters from which to start the optimization. If None, the
optimization will start at the identity transform. n is the
number of parameters of the specified transformation.</p>
</dd>
<dt><strong>static_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1), optional</span></dt><dd><p>the voxel-to-space transformation associated with the static
image. The default is None, implying the transform is the
identity.</p>
</dd>
<dt><strong>moving_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1), optional</span></dt><dd><p>the voxel-to-space transformation associated with the moving
image. The default is None, implying the transform is the
identity.</p>
</dd>
<dt><strong>starting_affine</strong><span class="classifier">string, or matrix, or None, optional</span></dt><dd><dl class="simple">
<dt>If string:</dt><dd><p>‘mass’: align centers of gravity
‘voxel-origin’: align physical coordinates of voxel (0,0,0)
‘centers’: align physical coordinates of central voxels</p>
</dd>
<dt>If matrix:</dt><dd><p>array, shape (dim+1, dim+1).</p>
</dd>
<dt>If None:</dt><dd><p>Start from identity.</p>
</dd>
</dl>
<p>The default is None.</p>
</dd>
<dt><strong>ret_metric</strong><span class="classifier">boolean, optional</span></dt><dd><p>if True, it returns the parameters for measuring the
similarity between the images (default ‘False’).
The metric containing optimal parameters and
the distance between the images.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>affine_map</strong><span class="classifier">instance of AffineMap</span></dt><dd><p>the affine resulting affine transformation</p>
</dd>
<dt><strong>xopt</strong><span class="classifier">optimal parameters</span></dt><dd><p>the optimal parameters (translation, rotation shear etc.)</p>
</dd>
<dt><strong>fopt</strong><span class="classifier">Similarity metric</span></dt><dd><p>the value of the function at the optimal parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="isotropicscalespace">
<h3><a class="reference internal" href="#dipy.align.imaffine.IsotropicScaleSpace" title="dipy.align.imaffine.IsotropicScaleSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicScaleSpace</span></code></a><a class="headerlink" href="#isotropicscalespace" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imaffine.IsotropicScaleSpace">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">IsotropicScaleSpace</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">factors</em>, <em class="sig-param">sigmas</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">input_spacing=None</em>, <em class="sig-param">mask0=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.IsotropicScaleSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.scalespace.ScaleSpace" title="dipy.align.scalespace.ScaleSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.scalespace.ScaleSpace</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine</span></code>(level)</p></td>
<td><p>Voxel-to-space transformation at a given level</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine_inv</span></code>(level)</p></td>
<td><p>Space-to-voxel transformation at a given level</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_domain_shape</span></code>(level)</p></td>
<td><p>Shape the sub-sampled image must have at a particular level</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_expand_factors</span></code>(from_level, to_level)</p></td>
<td><p>Ratio of voxel size from pyramid level from_level to to_level</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_image</span></code>(level)</p></td>
<td><p>Smoothed image at a given level</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_scaling</span></code>(level)</p></td>
<td><p>Adjustment factor for input-spacing to reflect voxel sizes at level</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sigmas</span></code>(level)</p></td>
<td><p>Smoothing parameters used at a given level</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_spacing</span></code>(level)</p></td>
<td><p>Spacings the sub-sampled image must have at a particular level</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_level</span></code>(level)</p></td>
<td><p>Prints properties of a pyramid level</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imaffine.IsotropicScaleSpace.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">factors</em>, <em class="sig-param">sigmas</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">input_spacing=None</em>, <em class="sig-param">mask0=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.IsotropicScaleSpace.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>IsotropicScaleSpace</p>
<p>Computes the Scale Space representation of an image using isotropic
smoothing kernels for all scales. The scale space is simply a list
of images produced by smoothing the input image with a Gaussian
kernel with different smoothing parameters.</p>
<p>This specialization of ScaleSpace allows the user to provide custom
scale and smoothing factors for all scales.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array, shape (r,c) or (s, r, c) where s is the number of</span></dt><dd><p>slices, r is the number of rows and c is the number of columns of
the input image.</p>
</dd>
<dt><strong>factors</strong><span class="classifier">list of floats</span></dt><dd><p>custom scale factors to build the scale space (one factor for each
scale).</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">list of floats</span></dt><dd><p>custom smoothing parameter to build the scale space (one parameter
for each scale).</p>
</dd>
<dt><strong>image_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-space transform of the image grid. The default is
the identity matrix.</p>
</dd>
<dt><strong>input_spacing</strong><span class="classifier">array, shape (dim,), optional</span></dt><dd><p>the spacing (voxel size) between voxels in physical space. The
default if 1.0 along all axes.</p>
</dd>
<dt><strong>mask0</strong><span class="classifier">Boolean, optional</span></dt><dd><p>if True, all smoothed images will be zero at all voxels that are
zero in the input image. The default is False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mutualinformationmetric">
<h3><a class="reference internal" href="#dipy.align.imaffine.MutualInformationMetric" title="dipy.align.imaffine.MutualInformationMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutualInformationMetric</span></code></a><a class="headerlink" href="#mutualinformationmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imaffine.MutualInformationMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">MutualInformationMetric</code><span class="sig-paren">(</span><em class="sig-param">nbins=32</em>, <em class="sig-param">sampling_proportion=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.MutualInformationMetric.distance" title="dipy.align.imaffine.MutualInformationMetric.distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code></a>(params)</p></td>
<td><p>Numeric value of the negative Mutual Information.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.MutualInformationMetric.distance_and_gradient" title="dipy.align.imaffine.MutualInformationMetric.distance_and_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance_and_gradient</span></code></a>(params)</p></td>
<td><p>Numeric value of the metric and its gradient at given parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.MutualInformationMetric.gradient" title="dipy.align.imaffine.MutualInformationMetric.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a>(params)</p></td>
<td><p>Numeric value of the metric’s gradient at the given parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.MutualInformationMetric.setup" title="dipy.align.imaffine.MutualInformationMetric.setup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setup</span></code></a>(transform, static, moving[, …])</p></td>
<td><p>Prepare the metric to compute intensity densities and gradients.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imaffine.MutualInformationMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">nbins=32</em>, <em class="sig-param">sampling_proportion=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an instance of the Mutual Information metric.</p>
<p>This class implements the methods required by Optimizer to drive the
registration process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>the number of bins to be used for computing the intensity
histograms. The default is 32.</p>
</dd>
<dt><strong>sampling_proportion</strong><span class="classifier">None or float in interval (0, 1], optional</span></dt><dd><p>There are two types of sampling: dense and sparse. Dense sampling
uses all voxels for estimating the (joint and marginal) intensity
histograms, while sparse sampling uses a subset of them. If
<cite>sampling_proportion</cite> is None, then dense sampling is
used. If <cite>sampling_proportion</cite> is a floating point value in (0,1]
then sparse sampling is used, where <cite>sampling_proportion</cite>
specifies the proportion of voxels to be used. The default is
None.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Since we use linear interpolation, images are not, in general,
differentiable at exact voxel coordinates, but they are differentiable
between voxel coordinates. When using sparse sampling, selected voxels
are slightly moved by adding a small random displacement within one
voxel to prevent sampling points from being located exactly at voxel
coordinates. When using dense sampling, this random displacement is
not applied.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.MutualInformationMetric.distance">
<code class="sig-name descname">distance</code><span class="sig-paren">(</span><em class="sig-param">params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Numeric value of the negative Mutual Information.</p>
<p>We need to change the sign so we can use standard minimization
algorithms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>the parameter vector of the transform currently used by the metric
(the transform name is provided when self.setup is called), n is
the number of parameters of the transform</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>neg_mi</strong><span class="classifier">float</span></dt><dd><p>the negative mutual information of the input images after
transforming the moving image by the currently set transform
with <cite>params</cite> parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.MutualInformationMetric.distance_and_gradient">
<code class="sig-name descname">distance_and_gradient</code><span class="sig-paren">(</span><em class="sig-param">params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric.distance_and_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Numeric value of the metric and its gradient at given parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>the parameter vector of the transform currently used by the metric
(the transform name is provided when self.setup is called), n is
the number of parameters of the transform</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>neg_mi</strong><span class="classifier">float</span></dt><dd><p>the negative mutual information of the input images after
transforming the moving image by the currently set transform
with <cite>params</cite> parameters</p>
</dd>
<dt><strong>neg_mi_grad</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>the gradient of the negative Mutual Information</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.MutualInformationMetric.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">params</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Numeric value of the metric’s gradient at the given parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>the parameter vector of the transform currently used by the metric
(the transform name is provided when self.setup is called), n is
the number of parameters of the transform</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>grad</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>the gradient of the negative Mutual Information</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.MutualInformationMetric.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">transform</em>, <em class="sig-param">static</em>, <em class="sig-param">moving</em>, <em class="sig-param">static_grid2world=None</em>, <em class="sig-param">moving_grid2world=None</em>, <em class="sig-param">starting_affine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.MutualInformationMetric.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare the metric to compute intensity densities and gradients.</p>
<p>The histograms will be setup to compute probability densities of
intensities within the minimum and maximum values of <cite>static</cite> and
<cite>moving</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>transform: instance of Transform</strong></dt><dd><p>the transformation with respect to whose parameters the gradient
must be computed</p>
</dd>
<dt><strong>static</strong><span class="classifier">array, shape (S, R, C) or (R, C)</span></dt><dd><p>static image</p>
</dd>
<dt><strong>moving</strong><span class="classifier">array, shape (S’, R’, C’) or (R’, C’)</span></dt><dd><p>moving image. The dimensions of the static (S, R, C) and moving
(S’, R’, C’) images do not need to be the same.</p>
</dd>
<dt><strong>static_grid2world</strong><span class="classifier">array (dim+1, dim+1), optional</span></dt><dd><p>the grid-to-space transform of the static image. The default is
None, implying the transform is the identity.</p>
</dd>
<dt><strong>moving_grid2world</strong><span class="classifier">array (dim+1, dim+1)</span></dt><dd><p>the grid-to-space transform of the moving image. The default is
None, implying the spacing along all axes is 1.</p>
</dd>
<dt><strong>starting_affine</strong><span class="classifier">array, shape (dim+1, dim+1), optional</span></dt><dd><p>the pre-aligning matrix (an affine transform) that roughly aligns
the moving image towards the static image. If None, no
pre-alignment is performed. If a pre-alignment matrix is available,
it is recommended to provide this matrix as <cite>starting_affine</cite>
instead of manually transforming the moving image to reduce
interpolation artifacts. The default is None, implying no
pre-alignment is performed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="optimizer">
<h3><a class="reference internal" href="#dipy.align.imaffine.Optimizer" title="dipy.align.imaffine.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Optimizer</span></code></a><a class="headerlink" href="#optimizer" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imaffine.Optimizer">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">Optimizer</code><span class="sig-paren">(</span><em class="sig-param">fun</em>, <em class="sig-param">x0</em>, <em class="sig-param">args=()</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">jac=None</em>, <em class="sig-param">hess=None</em>, <em class="sig-param">hessp=None</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">constraints=()</em>, <em class="sig-param">tol=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">options=None</em>, <em class="sig-param">evolution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.Optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evolution</strong></dt><dd></dd>
<dt><strong>fopt</strong></dt><dd></dd>
<dt><strong>message</strong></dt><dd></dd>
<dt><strong>nfev</strong></dt><dd></dd>
<dt><strong>nit</strong></dt><dd></dd>
<dt><strong>xopt</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>print_summary</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imaffine.Optimizer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">fun</em>, <em class="sig-param">x0</em>, <em class="sig-param">args=()</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">jac=None</em>, <em class="sig-param">hess=None</em>, <em class="sig-param">hessp=None</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">constraints=()</em>, <em class="sig-param">tol=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">options=None</em>, <em class="sig-param">evolution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.Optimizer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for handling minimization of scalar function of one or more
variables.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>fun</strong><span class="classifier">callable</span></dt><dd><p>Objective function.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">ndarray</span></dt><dd><p>Initial guess.</p>
</dd>
<dt><strong>args</strong><span class="classifier">tuple, optional</span></dt><dd><p>Extra arguments passed to the objective function and its
derivatives (Jacobian, Hessian).</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>Type of solver.  Should be one of</p>
<blockquote>
<div><ul class="simple">
<li><p>‘Nelder-Mead’</p></li>
<li><p>‘Powell’</p></li>
<li><p>‘CG’</p></li>
<li><p>‘BFGS’</p></li>
<li><p>‘Newton-CG’</p></li>
<li><p>‘Anneal’</p></li>
<li><p>‘L-BFGS-B’</p></li>
<li><p>‘TNC’</p></li>
<li><p>‘COBYLA’</p></li>
<li><p>‘SLSQP’</p></li>
<li><p>‘dogleg’</p></li>
<li><p>‘trust-ncg’</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>jac</strong><span class="classifier">bool or callable, optional</span></dt><dd><p>Jacobian of objective function. Only for CG, BFGS, Newton-CG,
dogleg, trust-ncg.
If <cite>jac</cite> is a Boolean and is True, <cite>fun</cite> is assumed to return the
value of Jacobian along with the objective function. If False, the
Jacobian will be estimated numerically.
<cite>jac</cite> can also be a callable returning the Jacobian of the
objective. In this case, it must accept the same arguments
as <cite>fun</cite>.</p>
</dd>
<dt><strong>hess, hessp</strong><span class="classifier">callable, optional</span></dt><dd><p>Hessian of objective function or Hessian of objective function
times an arbitrary vector p.  Only for Newton-CG,
dogleg, trust-ncg.
Only one of <cite>hessp</cite> or <cite>hess</cite> needs to be given.  If <cite>hess</cite> is
provided, then <cite>hessp</cite> will be ignored.  If neither <cite>hess</cite> nor
<cite>hessp</cite> is provided, then the hessian product will be approximated
using finite differences on <cite>jac</cite>. <cite>hessp</cite> must compute the Hessian
times an arbitrary vector.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">sequence, optional</span></dt><dd><p>Bounds for variables (only for L-BFGS-B, TNC and SLSQP).
<code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining
the bounds on that parameter. Use None for one of <code class="docutils literal notranslate"><span class="pre">min</span></code> or
<code class="docutils literal notranslate"><span class="pre">max</span></code> when there is no bound in that direction.</p>
</dd>
<dt><strong>constraints</strong><span class="classifier">dict or sequence of dict, optional</span></dt><dd><p>Constraints definition (only for COBYLA and SLSQP).
Each constraint is defined in a dictionary with fields:</p>
<blockquote>
<div><dl class="simple">
<dt>type<span class="classifier">str</span></dt><dd><p>Constraint type: ‘eq’ for equality, ‘ineq’ for inequality.</p>
</dd>
<dt>fun<span class="classifier">callable</span></dt><dd><p>The function defining the constraint.</p>
</dd>
<dt>jac<span class="classifier">callable, optional</span></dt><dd><p>The Jacobian of <cite>fun</cite> (only for SLSQP).</p>
</dd>
<dt>args<span class="classifier">sequence, optional</span></dt><dd><p>Extra arguments to be passed to the function and Jacobian.</p>
</dd>
</dl>
</div></blockquote>
<p>Equality constraint means that the constraint function result is to
be zero whereas inequality means that it is to be non-negative.
Note that COBYLA only supports inequality constraints.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance for termination. For detailed control, use
solver-specific options.</p>
</dd>
<dt><strong>callback</strong><span class="classifier">callable, optional</span></dt><dd><p>Called after each iteration, as <code class="docutils literal notranslate"><span class="pre">callback(xk)</span></code>, where <code class="docutils literal notranslate"><span class="pre">xk</span></code> is
the current parameter vector. Only available using Scipy &gt;= 0.12.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>A dictionary of solver options. All methods accept the following
generic options:</p>
<blockquote>
<div><dl class="simple">
<dt>maxiter<span class="classifier">int</span></dt><dd><p>Maximum number of iterations to perform.</p>
</dd>
<dt>disp<span class="classifier">bool</span></dt><dd><p>Set to True to print convergence messages.</p>
</dd>
</dl>
</div></blockquote>
<p>For method-specific options, see
<cite>show_options(‘minimize’, method)</cite>.</p>
</dd>
<dt><strong>evolution</strong><span class="classifier">bool, optional</span></dt><dd><p>save history of x for each iteration. Only available using Scipy
&gt;= 0.12.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.Optimizer.evolution">
<em class="property">property </em><code class="sig-name descname">evolution</code><a class="headerlink" href="#dipy.align.imaffine.Optimizer.evolution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.Optimizer.fopt">
<em class="property">property </em><code class="sig-name descname">fopt</code><a class="headerlink" href="#dipy.align.imaffine.Optimizer.fopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.Optimizer.message">
<em class="property">property </em><code class="sig-name descname">message</code><a class="headerlink" href="#dipy.align.imaffine.Optimizer.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.Optimizer.nfev">
<em class="property">property </em><code class="sig-name descname">nfev</code><a class="headerlink" href="#dipy.align.imaffine.Optimizer.nfev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.Optimizer.nit">
<em class="property">property </em><code class="sig-name descname">nit</code><a class="headerlink" href="#dipy.align.imaffine.Optimizer.nit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.Optimizer.print_summary">
<code class="sig-name descname">print_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.Optimizer.print_summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.Optimizer.xopt">
<em class="property">property </em><code class="sig-name descname">xopt</code><a class="headerlink" href="#dipy.align.imaffine.Optimizer.xopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="parzenjointhistogram">
<h3><a class="reference internal" href="#dipy.align.imaffine.ParzenJointHistogram" title="dipy.align.imaffine.ParzenJointHistogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParzenJointHistogram</span></code></a><a class="headerlink" href="#parzenjointhistogram" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imaffine.ParzenJointHistogram">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">ParzenJointHistogram</code><a class="headerlink" href="#dipy.align.imaffine.ParzenJointHistogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.ParzenJointHistogram.bin_index" title="dipy.align.imaffine.ParzenJointHistogram.bin_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bin_index</span></code></a></p></td>
<td><p>Bin index associated with the given normalized intensity</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.ParzenJointHistogram.bin_normalize_moving" title="dipy.align.imaffine.ParzenJointHistogram.bin_normalize_moving"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bin_normalize_moving</span></code></a></p></td>
<td><p>Maps intensity x to the range covered by the moving histogram</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.ParzenJointHistogram.bin_normalize_static" title="dipy.align.imaffine.ParzenJointHistogram.bin_normalize_static"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bin_normalize_static</span></code></a></p></td>
<td><p>Maps intensity x to the range covered by the static histogram</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.ParzenJointHistogram.setup" title="dipy.align.imaffine.ParzenJointHistogram.setup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setup</span></code></a></p></td>
<td><p>Compute histogram settings to store the PDF of input images</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.ParzenJointHistogram.update_gradient_dense" title="dipy.align.imaffine.ParzenJointHistogram.update_gradient_dense"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_gradient_dense</span></code></a></p></td>
<td><p>Computes the Gradient of the joint PDF w.r.t.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.ParzenJointHistogram.update_gradient_sparse" title="dipy.align.imaffine.ParzenJointHistogram.update_gradient_sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_gradient_sparse</span></code></a></p></td>
<td><p>Computes the Gradient of the joint PDF w.r.t.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.ParzenJointHistogram.update_pdfs_dense" title="dipy.align.imaffine.ParzenJointHistogram.update_pdfs_dense"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_pdfs_dense</span></code></a></p></td>
<td><p>Computes the Probability Density Functions of two images</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.ParzenJointHistogram.update_pdfs_sparse" title="dipy.align.imaffine.ParzenJointHistogram.update_pdfs_sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_pdfs_sparse</span></code></a></p></td>
<td><p>Computes the Probability Density Functions from a set of samples</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imaffine.ParzenJointHistogram.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ParzenJointHistogram.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes joint histogram and derivatives with Parzen windows</p>
<p>Base class to compute joint and marginal probability density
functions and their derivatives with respect to a transform’s
parameters. The smooth histograms are computed by using Parzen
windows [Parzen62] with a cubic spline kernel, as proposed by
Mattes et al. [Mattes03]. This implementation is not tied to any
optimization (registration) method, the idea is that
information-theoretic matching functionals (such as Mutual
Information) can inherit from this class to perform the low-level
computations of the joint intensity distributions and its gradient
w.r.t. the transform parameters. The derived class can then compute
the similarity/dissimilarity measure and gradient, and finally
communicate the results to the appropriate optimizer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbins</strong><span class="classifier">int</span></dt><dd><p>the number of bins of the joint and marginal probability density
functions (the actual number of bins of the joint PDF is nbins**2)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We need this class in cython to allow _joint_pdf_gradient_dense_2d and
_joint_pdf_gradient_dense_3d to use a nogil Jacobian function (obtained
from an instance of the Transform class), which allows us to evaluate
Jacobians at all the sampling points (maybe the full grid) inside a
nogil loop.</p>
<p>The reason we need a class is to encapsulate all the parameters related
to the joint and marginal distributions.</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[Parzen62] E. Parzen. On the estimation of a probability density</dt><dd><p>function and the mode. Annals of Mathematical Statistics,
33(3), 1065-1076, 1962.</p>
</dd>
<dt>[Mattes03] Mattes, D., Haynor, D. R., Vesselle, H., Lewellen, T. K.,</dt><dd><p>&amp; Eubank, W. PET-CT image registration in the chest using
free-form deformations. IEEE Transactions on Medical
Imaging, 22(1), 120-8, 2003.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.align.imaffine.ParzenJointHistogram.bin_index">
<code class="sig-name descname">bin_index</code><a class="headerlink" href="#dipy.align.imaffine.ParzenJointHistogram.bin_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Bin index associated with the given normalized intensity</p>
<p>The return value is an integer in [padding, nbins - 1 - padding]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xnorm</strong><span class="classifier">float</span></dt><dd><p>intensity value normalized to the range covered by the histogram</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bin</strong><span class="classifier">int</span></dt><dd><p>the bin index associated with the given normalized intensity</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.align.imaffine.ParzenJointHistogram.bin_normalize_moving">
<code class="sig-name descname">bin_normalize_moving</code><a class="headerlink" href="#dipy.align.imaffine.ParzenJointHistogram.bin_normalize_moving" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps intensity x to the range covered by the moving histogram</p>
<p>If the input intensity is in [self.mmin, self.mmax] then the normalized
intensity will be in [self.padding, self.nbins - self.padding]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">float</span></dt><dd><p>the intensity to be normalized</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xnorm</strong><span class="classifier">float</span></dt><dd><p>normalized intensity to the range covered by the moving histogram</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.align.imaffine.ParzenJointHistogram.bin_normalize_static">
<code class="sig-name descname">bin_normalize_static</code><a class="headerlink" href="#dipy.align.imaffine.ParzenJointHistogram.bin_normalize_static" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps intensity x to the range covered by the static histogram</p>
<p>If the input intensity is in [self.smin, self.smax] then the normalized
intensity will be in [self.padding, self.nbins - self.padding]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">float</span></dt><dd><p>the intensity to be normalized</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xnorm</strong><span class="classifier">float</span></dt><dd><p>normalized intensity to the range covered by the static histogram</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.align.imaffine.ParzenJointHistogram.setup">
<code class="sig-name descname">setup</code><a class="headerlink" href="#dipy.align.imaffine.ParzenJointHistogram.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute histogram settings to store the PDF of input images</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">array</span></dt><dd><p>static image</p>
</dd>
<dt><strong>moving</strong><span class="classifier">array</span></dt><dd><p>moving image</p>
</dd>
<dt><strong>smask</strong><span class="classifier">array</span></dt><dd><p>mask of static object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
If None, the behaviour is equivalent to smask=ones_like(static)</p>
</dd>
<dt><strong>mmask</strong><span class="classifier">array</span></dt><dd><p>mask of moving object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
If None, the behaviour is equivalent to mmask=ones_like(static)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.align.imaffine.ParzenJointHistogram.update_gradient_dense">
<code class="sig-name descname">update_gradient_dense</code><a class="headerlink" href="#dipy.align.imaffine.ParzenJointHistogram.update_gradient_dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Gradient of the joint PDF w.r.t. transform parameters</p>
<p>Computes the vector of partial derivatives of the joint histogram
w.r.t. each transformation parameter.</p>
<p>The gradient is stored in self.joint_grad.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>theta</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>parameters of the transformation to compute the gradient from</p>
</dd>
<dt><strong>transform</strong><span class="classifier">instance of Transform</span></dt><dd><p>the transformation with respect to whose parameters the gradient
must be computed</p>
</dd>
<dt><strong>static</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>static image</p>
</dd>
<dt><strong>moving</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>moving image</p>
</dd>
<dt><strong>grid2world</strong><span class="classifier">array, shape (4, 4)</span></dt><dd><p>we assume that both images have already been sampled at a common
grid. This transform must map voxel coordinates of this common grid
to physical coordinates of its corresponding voxel in the moving
image. For example, if the moving image was sampled on the static
image’s grid (this is the typical setting) using an aligning
matrix A, then</p>
<ol class="arabic simple">
<li><p>grid2world = A.dot(static_affine)</p></li>
</ol>
<p>where static_affine is the transformation mapping static image’s
grid coordinates to physical space.</p>
</dd>
<dt><strong>mgradient</strong><span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt><strong>smask</strong><span class="classifier">array, shape (S, R, C), optional</span></dt><dd><p>mask of static object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
The default is None, indicating all voxels are considered.</p>
</dd>
<dt><strong>mmask</strong><span class="classifier">array, shape (S, R, C), optional</span></dt><dd><p>mask of moving object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
The default is None, indicating all voxels are considered.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.align.imaffine.ParzenJointHistogram.update_gradient_sparse">
<code class="sig-name descname">update_gradient_sparse</code><a class="headerlink" href="#dipy.align.imaffine.ParzenJointHistogram.update_gradient_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Gradient of the joint PDF w.r.t. transform parameters</p>
<p>Computes the vector of partial derivatives of the joint histogram
w.r.t. each transformation parameter.</p>
<p>The list of intensities <cite>sval</cite> and <cite>mval</cite> are assumed to be sampled
from the static and moving images, respectively, at the same
physical points. Of course, the images may not be perfectly aligned
at the moment the sampling was performed. The resulting  gradient
corresponds to the paired intensities according to the alignment at the
moment the images were sampled.</p>
<p>The gradient is stored in self.joint_grad.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>parameters to compute the gradient at</p>
</dd>
<dt><strong>transform</strong><span class="classifier">instance of Transform</span></dt><dd><p>the transformation with respect to whose parameters the gradient
must be computed</p>
</dd>
<dt><strong>sval</strong><span class="classifier">array, shape (m,)</span></dt><dd><p>sampled intensities from the static image at sampled_points</p>
</dd>
<dt><strong>mval</strong><span class="classifier">array, shape (m,)</span></dt><dd><p>sampled intensities from the moving image at sampled_points</p>
</dd>
<dt><strong>sample_points</strong><span class="classifier">array, shape (m, 3)</span></dt><dd><p>coordinates (in physical space) of the points the images were
sampled at</p>
</dd>
<dt><strong>mgradient</strong><span class="classifier">array, shape (m, 3)</span></dt><dd><p>the gradient of the moving image at the sample points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.align.imaffine.ParzenJointHistogram.update_pdfs_dense">
<code class="sig-name descname">update_pdfs_dense</code><a class="headerlink" href="#dipy.align.imaffine.ParzenJointHistogram.update_pdfs_dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Probability Density Functions of two images</p>
<p>The joint PDF is stored in self.joint. The marginal distributions
corresponding to the static and moving images are computed and
stored in self.smarginal and self.mmarginal, respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>static image</p>
</dd>
<dt><strong>moving</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>moving image</p>
</dd>
<dt><strong>smask</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>mask of static object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
If None, ones_like(static) is used as mask.</p>
</dd>
<dt><strong>mmask</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>mask of moving object being registered (a binary array with 1’s
inside the object of interest and 0’s along the background).
If None, ones_like(moving) is used as mask.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="dipy.align.imaffine.ParzenJointHistogram.update_pdfs_sparse">
<code class="sig-name descname">update_pdfs_sparse</code><a class="headerlink" href="#dipy.align.imaffine.ParzenJointHistogram.update_pdfs_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Probability Density Functions from a set of samples</p>
<p>The list of intensities <cite>sval</cite> and <cite>mval</cite> are assumed to be sampled
from the static and moving images, respectively, at the same
physical points. Of course, the images may not be perfectly aligned
at the moment the sampling was performed. The resulting  distributions
corresponds to the paired intensities according to the alignment at the
moment the images were sampled.</p>
<p>The joint PDF is stored in self.joint. The marginal distributions
corresponding to the static and moving images are computed and
stored in self.smarginal and self.mmarginal, respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sval</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>sampled intensities from the static image at sampled_points</p>
</dd>
<dt><strong>mval</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>sampled intensities from the moving image at sampled_points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="scalespace">
<h3><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace" title="dipy.align.imaffine.ScaleSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a><a class="headerlink" href="#scalespace" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imaffine.ScaleSpace">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">ScaleSpace</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">num_levels</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">input_spacing=None</em>, <em class="sig-param">sigma_factor=0.2</em>, <em class="sig-param">mask0=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace.get_affine" title="dipy.align.imaffine.ScaleSpace.get_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine</span></code></a>(level)</p></td>
<td><p>Voxel-to-space transformation at a given level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace.get_affine_inv" title="dipy.align.imaffine.ScaleSpace.get_affine_inv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine_inv</span></code></a>(level)</p></td>
<td><p>Space-to-voxel transformation at a given level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace.get_domain_shape" title="dipy.align.imaffine.ScaleSpace.get_domain_shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_domain_shape</span></code></a>(level)</p></td>
<td><p>Shape the sub-sampled image must have at a particular level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace.get_expand_factors" title="dipy.align.imaffine.ScaleSpace.get_expand_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_expand_factors</span></code></a>(from_level, to_level)</p></td>
<td><p>Ratio of voxel size from pyramid level from_level to to_level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace.get_image" title="dipy.align.imaffine.ScaleSpace.get_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_image</span></code></a>(level)</p></td>
<td><p>Smoothed image at a given level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace.get_scaling" title="dipy.align.imaffine.ScaleSpace.get_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_scaling</span></code></a>(level)</p></td>
<td><p>Adjustment factor for input-spacing to reflect voxel sizes at level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace.get_sigmas" title="dipy.align.imaffine.ScaleSpace.get_sigmas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sigmas</span></code></a>(level)</p></td>
<td><p>Smoothing parameters used at a given level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace.get_spacing" title="dipy.align.imaffine.ScaleSpace.get_spacing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_spacing</span></code></a>(level)</p></td>
<td><p>Spacings the sub-sampled image must have at a particular level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imaffine.ScaleSpace.print_level" title="dipy.align.imaffine.ScaleSpace.print_level"><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_level</span></code></a>(level)</p></td>
<td><p>Prints properties of a pyramid level</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imaffine.ScaleSpace.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">num_levels</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">input_spacing=None</em>, <em class="sig-param">sigma_factor=0.2</em>, <em class="sig-param">mask0=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>ScaleSpace</p>
<p>Computes the Scale Space representation of an image. The scale space is
simply a list of images produced by smoothing the input image with a
Gaussian kernel with increasing smoothing parameter. If the image’s
voxels are isotropic, the smoothing will be the same along all
directions: at level L = 0, 1, …, the sigma is given by
<span class="math notranslate nohighlight">\(s * ( 2^L - 1 )\)</span>.
If the voxel dimensions are not isotropic, then the smoothing is
weaker along low resolution directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array, shape (r,c) or (s, r, c) where s is the number of</span></dt><dd><p>slices, r is the number of rows and c is the number of columns of
the input image.</p>
</dd>
<dt><strong>num_levels</strong><span class="classifier">int</span></dt><dd><p>the desired number of levels (resolutions) of the scale space</p>
</dd>
<dt><strong>image_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-space transform of the image grid. The default is
the identity matrix</p>
</dd>
<dt><strong>input_spacing</strong><span class="classifier">array, shape (dim,), optional</span></dt><dd><p>the spacing (voxel size) between voxels in physical space. The
default is 1.0 along all axes</p>
</dd>
<dt><strong>sigma_factor</strong><span class="classifier">float, optional</span></dt><dd><p>the smoothing factor to be used in the construction of the scale
space. The default is 0.2</p>
</dd>
<dt><strong>mask0</strong><span class="classifier">Boolean, optional</span></dt><dd><p>if True, all smoothed images will be zero at all voxels that are
zero in the input image. The default is False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.ScaleSpace.get_affine">
<code class="sig-name descname">get_affine</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Voxel-to-space transformation at a given level</p>
<p>Returns the voxel-to-space transformation associated with the
sub-sampled image at a particular resolution of the scale space (note
that this object does not explicitly subsample the smoothed images, but
only provides the properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get affine transform from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the affine (voxel-to-space) transform at the requested resolution</strong></dt><dd><p>or None if an invalid level was requested</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.ScaleSpace.get_affine_inv">
<code class="sig-name descname">get_affine_inv</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace.get_affine_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Space-to-voxel transformation at a given level</p>
<p>Returns the space-to-voxel transformation associated with the
sub-sampled image at a particular resolution of the scale space (note
that this object does not explicitly subsample the smoothed images, but
only provides the properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the inverse transform from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the inverse (space-to-voxel) transform at the requested resolution or</strong></dt><dd></dd>
<dt><strong>None if an invalid level was requested</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.ScaleSpace.get_domain_shape">
<code class="sig-name descname">get_domain_shape</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace.get_domain_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shape the sub-sampled image must have at a particular level</p>
<p>Returns the shape the sub-sampled image must have at a particular
resolution of the scale space (note that this object does not
explicitly subsample the smoothed images, but only provides the
properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the sub-sampled shape from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the sub-sampled shape at the requested resolution or None if an</strong></dt><dd><p>invalid level was requested</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.ScaleSpace.get_expand_factors">
<code class="sig-name descname">get_expand_factors</code><span class="sig-paren">(</span><em class="sig-param">from_level</em>, <em class="sig-param">to_level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace.get_expand_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Ratio of voxel size from pyramid level from_level to to_level</p>
<p>Given two scale space resolutions a = from_level, b = to_level,
returns the ratio of voxels size at level b to voxel size at level a
(the factor that must be used to multiply voxels at level a to
‘expand’ them to level b).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>from_level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the resolution to expand voxels from</p>
</dd>
<dt><strong>to_level</strong><span class="classifier">int, 0 &lt;= to_level &lt; from_level</span></dt><dd><p>the resolution to expand voxels to</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>factors</strong><span class="classifier">array, shape (k,), k = 2, 3</span></dt><dd><p>the expand factors (a scalar for each voxel dimension)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.ScaleSpace.get_image">
<code class="sig-name descname">get_image</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace.get_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothed image at a given level</p>
<p>Returns the smoothed image at the requested level in the Scale Space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the smooth image from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the smooth image at the requested resolution or None if an invalid</strong></dt><dd><p>level was requested</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.ScaleSpace.get_scaling">
<code class="sig-name descname">get_scaling</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace.get_scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjustment factor for input-spacing to reflect voxel sizes at level</p>
<p>Returns the scaling factor that needs to be applied to the input
spacing (the voxel sizes of the image at level 0 of the scale space) to
transform them to voxel sizes at the requested level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the scalings from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the scaling factors from the original spacing to the spacings at the</strong></dt><dd></dd>
<dt><strong>requested level</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.ScaleSpace.get_sigmas">
<code class="sig-name descname">get_sigmas</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace.get_sigmas" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothing parameters used at a given level</p>
<p>Returns the smoothing parameters (a scalar for each axis) used at the
requested level of the scale space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the smoothing parameters from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the smoothing parameters at the requested level</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.ScaleSpace.get_spacing">
<code class="sig-name descname">get_spacing</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace.get_spacing" title="Permalink to this definition">¶</a></dt>
<dd><p>Spacings the sub-sampled image must have at a particular level</p>
<p>Returns the spacings (voxel sizes) the sub-sampled image must have at a
particular resolution of the scale space (note that this object does
not explicitly subsample the smoothed images, but only provides the
properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the sub-sampled shape from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the spacings (voxel sizes) at the requested resolution or None if an</strong></dt><dd></dd>
<dt><strong>invalid level was requested</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imaffine.ScaleSpace.print_level">
<code class="sig-name descname">print_level</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.ScaleSpace.print_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints properties of a pyramid level</p>
<p>Prints the properties of a level of this scale space to standard output</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to be printed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="compute-parzen-mi">
<h3>compute_parzen_mi<a class="headerlink" href="#compute-parzen-mi" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imaffine.compute_parzen_mi">
<code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">compute_parzen_mi</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.compute_parzen_mi" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the mutual information and its gradient (if requested)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>joint</strong><span class="classifier">array, shape (nbins, nbins)</span></dt><dd><p>the joint intensity distribution</p>
</dd>
<dt><strong>joint_gradient</strong><span class="classifier">array, shape (nbins, nbins, n)</span></dt><dd><p>the gradient of the joint distribution w.r.t. the transformation
parameters</p>
</dd>
<dt><strong>smarginal</strong><span class="classifier">array, shape (nbins,)</span></dt><dd><p>the marginal intensity distribution of the static image</p>
</dd>
<dt><strong>mmarginal</strong><span class="classifier">array, shape (nbins,)</span></dt><dd><p>the marginal intensity distribution of the moving image</p>
</dd>
<dt><strong>mi_gradient</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>the buffer in which to write the gradient of the mutual information.
If None, the gradient is not computed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="get-direction-and-spacings">
<h3>get_direction_and_spacings<a class="headerlink" href="#get-direction-and-spacings" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imaffine.get_direction_and_spacings">
<code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">get_direction_and_spacings</code><span class="sig-paren">(</span><em class="sig-param">affine</em>, <em class="sig-param">dim</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.get_direction_and_spacings" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the rotational and spacing components from a matrix</p>
<p>Extracts the rotational and spacing (voxel dimensions) components from a
matrix. An image gradient represents the local variation of the image’s
gray values per voxel. Since we are iterating on the physical space, we
need to compute the gradients as variation per millimeter, so we need to
divide each gradient’s component by the voxel size along the corresponding
axis, that’s what the spacings are used for. Since the image’s gradients
are oriented along the grid axes, we also need to re-orient the gradients
to be given in physical space coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">array, shape (k, k), k = 3, 4</span></dt><dd><p>the matrix transforming grid coordinates to physical space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>direction</strong><span class="classifier">array, shape (k-1, k-1)</span></dt><dd><p>the rotational component of the input matrix</p>
</dd>
<dt><strong>spacings</strong><span class="classifier">array, shape (k-1,)</span></dt><dd><p>the scaling component (voxel size) of the matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="interpolate-scalar-2d">
<h3>interpolate_scalar_2d<a class="headerlink" href="#interpolate-scalar-2d" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imaffine.interpolate_scalar_2d">
<code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">interpolate_scalar_2d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.interpolate_scalar_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Bilinear interpolation of a 2D scalar image</p>
<p>Interpolates the 2D image at the given locations. This function is
a wrapper for _interpolate_scalar_2d for testing purposes, it is
equivalent to scipy.ndimage.interpolation.map_coordinates with
bilinear interpolation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>field</strong><span class="classifier">array, shape (S, R)</span></dt><dd><p>the 2D image to be interpolated</p>
</dd>
<dt><strong>locations</strong><span class="classifier">array, shape (n, 2)</span></dt><dd><p>(locations[i,0], locations[i,1]), 0&lt;=i&lt;n must contain the row and
column coordinates to interpolate the image at</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>out[i], 0&lt;=i&lt;n will be the interpolated scalar at coordinates
locations[i,:], or 0 if locations[i,:] is outside the image</p>
</dd>
<dt><strong>inside</strong><span class="classifier">array, (n,)</span></dt><dd><p>if locations[i:] is inside the image then inside[i]=1, else
inside[i]=0</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="interpolate-scalar-3d">
<h3>interpolate_scalar_3d<a class="headerlink" href="#interpolate-scalar-3d" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imaffine.interpolate_scalar_3d">
<code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">interpolate_scalar_3d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.interpolate_scalar_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Trilinear interpolation of a 3D scalar image</p>
<p>Interpolates the 3D image at the given locations. This function is
a wrapper for _interpolate_scalar_3d for testing purposes, it is
equivalent to scipy.ndimage.interpolation.map_coordinates with
trilinear interpolation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>field</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the 3D image to be interpolated</p>
</dd>
<dt><strong>locations</strong><span class="classifier">array, shape (n, 3)</span></dt><dd><p>(locations[i,0], locations[i,1], locations[i,2), 0&lt;=i&lt;n must contain
the coordinates to interpolate the image at</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array, shape (n,)</span></dt><dd><p>out[i], 0&lt;=i&lt;n will be the interpolated scalar at coordinates
locations[i,:], or 0 if locations[i,:] is outside the image</p>
</dd>
<dt><strong>inside</strong><span class="classifier">array, (n,)</span></dt><dd><p>if locations[i,:] is inside the image then inside[i]=1, else
inside[i]=0</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="sample-domain-regular">
<h3>sample_domain_regular<a class="headerlink" href="#sample-domain-regular" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imaffine.sample_domain_regular">
<code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">sample_domain_regular</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.sample_domain_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Take floor(total_voxels/k) samples from a (2D or 3D) grid</p>
<p>The sampling is made by taking all pixels whose index (in lexicographical
order) is a multiple of k. Each selected point is slightly perturbed by
adding a realization of a normally distributed random variable and then
mapped to physical space by the given grid-to-space transform.</p>
<p>The lexicographical order of a pixels in a grid of shape (a, b, c) is
defined by assigning to each voxel position (i, j, k) the integer index</p>
<p>F((i, j, k)) = i * (b * c) + j * (c) + k</p>
<p>and sorting increasingly by this index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>the sampling rate, as described before</p>
</dd>
<dt><strong>shape</strong><span class="classifier">array, shape (dim,)</span></dt><dd><p>the shape of the grid to be sampled</p>
</dd>
<dt><strong>grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the grid-to-space transform</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float</span></dt><dd><p>the standard deviation of the Normal random distortion to be applied
to the sampled points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">array, shape (total_pixels//k, dim)</span></dt><dd><p>the matrix whose rows are the sampled points</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.align.parzenhist</span> <span class="k">import</span> <span class="n">sample_domain_regular</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dipy.align.vector_fields</span> <span class="k">as</span> <span class="nn">vf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid2world</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">sample_domain_regular</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">grid2world</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="n">k</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">isamples</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">isamples</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">indices</span><span class="o">%</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="transform-centers-of-mass">
<h3>transform_centers_of_mass<a class="headerlink" href="#transform-centers-of-mass" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imaffine.transform_centers_of_mass">
<code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">transform_centers_of_mass</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">static_grid2world</em>, <em class="sig-param">moving</em>, <em class="sig-param">moving_grid2world</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.transform_centers_of_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation to align the center of mass of the input images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>static image</p>
</dd>
<dt><strong>static_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the static image</p>
</dd>
<dt><strong>moving</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>moving image</p>
</dd>
<dt><strong>moving_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the moving image</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>affine_map</strong><span class="classifier">instance of AffineMap</span></dt><dd><p>the affine transformation (translation only, in this case) aligning
the center of mass of the moving image towards the one of the static
image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="transform-geometric-centers">
<h3>transform_geometric_centers<a class="headerlink" href="#transform-geometric-centers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imaffine.transform_geometric_centers">
<code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">transform_geometric_centers</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">static_grid2world</em>, <em class="sig-param">moving</em>, <em class="sig-param">moving_grid2world</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.transform_geometric_centers" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation to align the geometric center of the input images.</p>
<p>With “geometric center” of a volume we mean the physical coordinates of
its central voxel</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>static image</p>
</dd>
<dt><strong>static_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the static image</p>
</dd>
<dt><strong>moving</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>moving image</p>
</dd>
<dt><strong>moving_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the moving image</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>affine_map</strong><span class="classifier">instance of AffineMap</span></dt><dd><p>the affine transformation (translation only, in this case) aligning
the geometric center of the moving image towards the one of the static
image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="transform-origins">
<h3>transform_origins<a class="headerlink" href="#transform-origins" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imaffine.transform_origins">
<code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">transform_origins</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">static_grid2world</em>, <em class="sig-param">moving</em>, <em class="sig-param">moving_grid2world</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.transform_origins" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation to align the origins of the input images.</p>
<p>With “origin” of a volume we mean the physical coordinates of
voxel (0,0,0)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>static image</p>
</dd>
<dt><strong>static_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the static image</p>
</dd>
<dt><strong>moving</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>moving image</p>
</dd>
<dt><strong>moving_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of the moving image</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>affine_map</strong><span class="classifier">instance of AffineMap</span></dt><dd><p>the affine transformation (translation only, in this case) aligning
the origin of the moving image towards the one of the static
image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="warn">
<h3>warn<a class="headerlink" href="#warn" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imaffine.warn">
<code class="sig-prename descclassname">dipy.align.imaffine.</code><code class="sig-name descname">warn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imaffine.warn" title="Permalink to this definition">¶</a></dt>
<dd><p>Issue a warning, or maybe ignore it or raise an exception.</p>
</dd></dl>

</div>
<div class="section" id="id1">
<h3><a class="reference internal" href="#dipy.align.imwarp.Bunch" title="dipy.align.imwarp.Bunch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bunch</span></code></a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imwarp.Bunch">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imwarp.</code><code class="sig-name descname">Bunch</code><span class="sig-paren">(</span><em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.Bunch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="method">
<dt id="dipy.align.imwarp.Bunch.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.Bunch.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A ‘bunch’ of values (a replacement of Enum)</p>
<p>This is a temporary replacement of Enum, which is not available
on all versions of Python 2</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffeomorphicmap">
<h3><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap" title="dipy.align.imwarp.DiffeomorphicMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffeomorphicMap</span></code></a><a class="headerlink" href="#diffeomorphicmap" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imwarp.DiffeomorphicMap">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imwarp.</code><code class="sig-name descname">DiffeomorphicMap</code><span class="sig-paren">(</span><em class="sig-param">dim</em>, <em class="sig-param">disp_shape</em>, <em class="sig-param">disp_grid2world=None</em>, <em class="sig-param">domain_shape=None</em>, <em class="sig-param">domain_grid2world=None</em>, <em class="sig-param">codomain_shape=None</em>, <em class="sig-param">codomain_grid2world=None</em>, <em class="sig-param">prealign=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.allocate" title="dipy.align.imwarp.DiffeomorphicMap.allocate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">allocate</span></code></a>()</p></td>
<td><p>Creates a zero displacement field</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.compute_inversion_error" title="dipy.align.imwarp.DiffeomorphicMap.compute_inversion_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_inversion_error</span></code></a>()</p></td>
<td><p>Inversion error of the displacement fields</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.expand_fields" title="dipy.align.imwarp.DiffeomorphicMap.expand_fields"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_fields</span></code></a>(expand_factors, new_shape)</p></td>
<td><p>Expands the displacement fields from current shape to new_shape</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.get_backward_field" title="dipy.align.imwarp.DiffeomorphicMap.get_backward_field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_backward_field</span></code></a>()</p></td>
<td><p>Deformation field to transform an image in the backward direction</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.get_forward_field" title="dipy.align.imwarp.DiffeomorphicMap.get_forward_field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_forward_field</span></code></a>()</p></td>
<td><p>Deformation field to transform an image in the forward direction</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.get_simplified_transform" title="dipy.align.imwarp.DiffeomorphicMap.get_simplified_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_simplified_transform</span></code></a>()</p></td>
<td><p>Constructs a simplified version of this Diffeomorhic Map</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.interpret_matrix" title="dipy.align.imwarp.DiffeomorphicMap.interpret_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpret_matrix</span></code></a>(obj)</p></td>
<td><p>Try to interpret <cite>obj</cite> as a matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.inverse" title="dipy.align.imwarp.DiffeomorphicMap.inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse</span></code></a>()</p></td>
<td><p>Inverse of this DiffeomorphicMap instance</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.shallow_copy" title="dipy.align.imwarp.DiffeomorphicMap.shallow_copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shallow_copy</span></code></a>()</p></td>
<td><p>Shallow copy of this DiffeomorphicMap instance</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.transform" title="dipy.align.imwarp.DiffeomorphicMap.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(image[, interpolation, …])</p></td>
<td><p>Warps an image in the forward direction</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.transform_inverse" title="dipy.align.imwarp.DiffeomorphicMap.transform_inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_inverse</span></code></a>(image[, interpolation, …])</p></td>
<td><p>Warps an image in the backward direction</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicMap.warp_endomorphism" title="dipy.align.imwarp.DiffeomorphicMap.warp_endomorphism"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp_endomorphism</span></code></a>(phi)</p></td>
<td><p>Composition of this DiffeomorphicMap with a given endomorphism</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">dim</em>, <em class="sig-param">disp_shape</em>, <em class="sig-param">disp_grid2world=None</em>, <em class="sig-param">domain_shape=None</em>, <em class="sig-param">domain_grid2world=None</em>, <em class="sig-param">codomain_shape=None</em>, <em class="sig-param">codomain_grid2world=None</em>, <em class="sig-param">prealign=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>DiffeomorphicMap</p>
<p>Implements a diffeomorphic transformation on the physical space. The
deformation fields encoding the direct and inverse transformations
share the same domain discretization (both the discretization grid
shape and voxel-to-space matrix). The input coordinates (physical
coordinates) are first aligned using prealign, and then displaced
using the corresponding vector field interpolated at the aligned
coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int, 2 or 3</span></dt><dd><p>the transformation’s dimension</p>
</dd>
<dt><strong>disp_shape</strong><span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of slices (if 3D), rows and columns of the deformation
field’s discretization</p>
</dd>
<dt><strong>disp_grid2world</strong><span class="classifier">the voxel-to-space transform between the def. fields</span></dt><dd><p>grid and space</p>
</dd>
<dt><strong>domain_shape</strong><span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of slices (if 3D), rows and columns of the default
discretizatio of this map’s domain</p>
</dd>
<dt><strong>domain_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the default voxel-to-space transformation between this map’s
discretization and physical space</p>
</dd>
<dt><strong>codomain_shape</strong><span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of slices (if 3D), rows and columns of the images that
are ‘normally’ warped using this transformation in the forward
direction (this will provide default transformation parameters to
warp images under this transformation). By default, we assume that
the inverse transformation is ‘normally’ used to warp images with
the same discretization and voxel-to-space transformation as the
deformation field grid.</p>
</dd>
<dt><strong>codomain_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation of images that are ‘normally’
warped using this transformation (in the forward direction).</p>
</dd>
<dt><strong>prealign</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the linear transformation to be applied to align input images to
the reference space before warping under the deformation field.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.allocate">
<code class="sig-name descname">allocate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.allocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a zero displacement field</p>
<p>Creates a zero displacement field (the identity transformation).</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.compute_inversion_error">
<code class="sig-name descname">compute_inversion_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.compute_inversion_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Inversion error of the displacement fields</p>
<p>Estimates the inversion error of the displacement fields by computing
statistics of the residual vectors obtained after composing the forward
and backward displacement fields.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>residual</strong><span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>the displacement field resulting from composing the forward and
backward displacement fields of this transformation (the residual
should be zero for a perfect diffeomorphism)</p>
</dd>
<dt><strong>stats</strong><span class="classifier">array, shape (3,)</span></dt><dd><p>statistics from the norms of the vectors of the residual
displacement field: maximum, mean and standard deviation</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Since the forward and backward displacement fields have the same
discretization, the final composition is given by</p>
<p>comp[i] = forward[ i + Dinv * backward[i]]</p>
<p>where Dinv is the space-to-grid transformation of the displacement
fields</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.expand_fields">
<code class="sig-name descname">expand_fields</code><span class="sig-paren">(</span><em class="sig-param">expand_factors</em>, <em class="sig-param">new_shape</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.expand_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Expands the displacement fields from current shape to new_shape</p>
<p>Up-samples the discretization of the displacement fields to be of
new_shape shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>expand_factors</strong><span class="classifier">array, shape (dim,)</span></dt><dd><p>the factors scaling current spacings (voxel sizes) to spacings in
the expanded discretization.</p>
</dd>
<dt><strong>new_shape</strong><span class="classifier">array, shape (dim,)</span></dt><dd><p>the shape of the arrays holding the up-sampled discretization</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.get_backward_field">
<code class="sig-name descname">get_backward_field</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.get_backward_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Deformation field to transform an image in the backward direction</p>
<p>Returns the deformation field that must be used to warp an image under
this transformation in the backward direction (note the ‘is_inverse’
flag).</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.get_forward_field">
<code class="sig-name descname">get_forward_field</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.get_forward_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Deformation field to transform an image in the forward direction</p>
<p>Returns the deformation field that must be used to warp an image under
this transformation in the forward direction (note the ‘is_inverse’
flag).</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.get_simplified_transform">
<code class="sig-name descname">get_simplified_transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.get_simplified_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a simplified version of this Diffeomorhic Map</p>
<p>The simplified version incorporates the pre-align transform, as well as
the domain and codomain affine transforms into the displacement field.
The resulting transformation may be regarded as operating on the
image spaces given by the domain and codomain discretization. As a
result, self.prealign, self.disp_grid2world, self.domain_grid2world and
self.codomain affine will be None (denoting Identity) in the resulting
diffeomorphic map.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.interpret_matrix">
<code class="sig-name descname">interpret_matrix</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.interpret_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to interpret <cite>obj</cite> as a matrix</p>
<p>Some operations are performed faster if we know in advance if a matrix
is the identity (so we can skip the actual matrix-vector
multiplication). This function returns None if the given object
is None or the ‘identity’ string. It returns the same object if it is
a numpy array. It raises an exception otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">object</span></dt><dd><p>any object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">object</span></dt><dd><p>the same object given as argument if <cite>obj</cite> is None or a numpy
array. None if <cite>obj</cite> is the ‘identity’ string.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.inverse">
<code class="sig-name descname">inverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of this DiffeomorphicMap instance</p>
<p>Returns a diffeomorphic map object representing the inverse of this
transformation. The internal arrays are not copied but just referenced.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inv</strong><span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the inverse of this diffeomorphic map.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.shallow_copy">
<code class="sig-name descname">shallow_copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.shallow_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Shallow copy of this DiffeomorphicMap instance</p>
<p>Creates a shallow copy of this diffeomorphic map (the arrays are not
copied but just referenced)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>new_map</strong><span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the shallow copy of this diffeomorphic map</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">interpolation='linear'</em>, <em class="sig-param">image_world2grid=None</em>, <em class="sig-param">out_shape=None</em>, <em class="sig-param">out_grid2world=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Warps an image in the forward direction</p>
<p>Transforms the input image under this transformation in the forward
direction. It uses the “is_inverse” flag to switch between “forward”
and “backward” (if is_inverse is False, then transform(…) warps the
image forwards, else it warps the image backwards).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array, shape (s, r, c) if dim = 3 or (r, c) if dim = 2</span></dt><dd><p>the image to be warped under this transformation in the forward
direction</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">string, either ‘linear’ or ‘nearest’</span></dt><dd><p>the type of interpolation to be used for warping, either ‘linear’
(for k-linear interpolation) or ‘nearest’ for nearest neighbor</p>
</dd>
<dt><strong>image_world2grid</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the transformation bringing world (space) coordinates to voxel
coordinates of the image given as input</p>
</dd>
<dt><strong>out_shape</strong><span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of slices, rows and columns of the desired warped image</p>
</dd>
<dt><strong>out_grid2world</strong><span class="classifier">the transformation bringing voxel coordinates of the</span></dt><dd><p>warped image to physical space</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">array, shape = out_shape or self.codomain_shape if None</span></dt><dd><p>the warped image under this transformation in the forward direction</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See _warp_forward and _warp_backward documentation for further
information.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.transform_inverse">
<code class="sig-name descname">transform_inverse</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">interpolation='linear'</em>, <em class="sig-param">image_world2grid=None</em>, <em class="sig-param">out_shape=None</em>, <em class="sig-param">out_grid2world=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.transform_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Warps an image in the backward direction</p>
<p>Transforms the input image under this transformation in the backward
direction. It uses the “is_inverse” flag to switch between “forward”
and “backward” (if is_inverse is False, then transform_inverse(…)
warps the image backwards, else it warps the image forwards)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array, shape (s, r, c) if dim = 3 or (r, c) if dim = 2</span></dt><dd><p>the image to be warped under this transformation in the forward
direction</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">string, either ‘linear’ or ‘nearest’</span></dt><dd><p>the type of interpolation to be used for warping, either ‘linear’
(for k-linear interpolation) or ‘nearest’ for nearest neighbor</p>
</dd>
<dt><strong>image_world2grid</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the transformation bringing world (space) coordinates to voxel
coordinates of the image given as input</p>
</dd>
<dt><strong>out_shape</strong><span class="classifier">array, shape (dim,)</span></dt><dd><p>the number of slices, rows and columns of the desired warped image</p>
</dd>
<dt><strong>out_grid2world</strong><span class="classifier">the transformation bringing voxel coordinates of the</span></dt><dd><p>warped image to physical space</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">array, shape = out_shape or self.codomain_shape if None</span></dt><dd><p>warped image under this transformation in the backward direction</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See _warp_forward and _warp_backward documentation for further
information.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicMap.warp_endomorphism">
<code class="sig-name descname">warp_endomorphism</code><span class="sig-paren">(</span><em class="sig-param">phi</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicMap.warp_endomorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Composition of this DiffeomorphicMap with a given endomorphism</p>
<p>Creates a new DiffeomorphicMap C with the same properties as self and
composes its displacement fields with phi’s corresponding fields.
The resulting diffeomorphism is of the form C(x) = phi(self(x)) with
inverse C^{-1}(y) = self^{-1}(phi^{-1}(y)). We assume that phi is an
endomorphism with the same discretization and domain affine as self
to ensure that the composition inherits self’s properties (we also
assume that the pre-aligning matrix of phi is None or identity).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>phi</strong><span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the endomorphism to be warped by this diffeomorphic map</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>composition</strong><span class="classifier">the composition of this diffeomorphic map with the</span></dt><dd><p>endomorphism given as input</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The problem with our current representation of a DiffeomorphicMap is
that the set of Diffeomorphism that can be represented this way (a
pre-aligning matrix followed by a non-linear endomorphism given as a
displacement field) is not closed under the composition operation.</p>
<p>Supporting a general DiffeomorphicMap class, closed under composition,
may be extremely costly computationally, and the kind of
transformations we actually need for Avants’ mid-point algorithm (SyN)
are much simpler.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="diffeomorphicregistration">
<h3><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicRegistration" title="dipy.align.imwarp.DiffeomorphicRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">DiffeomorphicRegistration</span></code></a><a class="headerlink" href="#diffeomorphicregistration" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imwarp.DiffeomorphicRegistration">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imwarp.</code><code class="sig-name descname">DiffeomorphicRegistration</code><span class="sig-paren">(</span><em class="sig-param">metric=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicRegistration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicRegistration.get_map" title="dipy.align.imwarp.DiffeomorphicRegistration.get_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_map</span></code></a>()</p></td>
<td><p>Returns the resulting diffeomorphic map after optimization</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicRegistration.optimize" title="dipy.align.imwarp.DiffeomorphicRegistration.optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize</span></code></a>()</p></td>
<td><p>Starts the metric optimization</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicRegistration.set_level_iters" title="dipy.align.imwarp.DiffeomorphicRegistration.set_level_iters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_level_iters</span></code></a>(level_iters)</p></td>
<td><p>Sets the number of iterations at each pyramid level</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicRegistration.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">metric=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicRegistration.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Diffeomorphic Registration</p>
<p>This abstract class defines the interface to be implemented by any
optimization algorithm for diffeomorphic registration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>metric</strong><span class="classifier">SimilarityMetric object</span></dt><dd><p>the object measuring the similarity of the two images. The
registration algorithm will minimize (or maximize) the provided
similarity.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicRegistration.get_map">
<em class="property">abstract </em><code class="sig-name descname">get_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicRegistration.get_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the resulting diffeomorphic map after optimization</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicRegistration.optimize">
<em class="property">abstract </em><code class="sig-name descname">optimize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicRegistration.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts the metric optimization</p>
<p>This is the main function each specialized class derived from this must
implement. Upon completion, the deformation field must be available
from the forward transformation model.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.DiffeomorphicRegistration.set_level_iters">
<code class="sig-name descname">set_level_iters</code><span class="sig-paren">(</span><em class="sig-param">level_iters</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.DiffeomorphicRegistration.set_level_iters" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the number of iterations at each pyramid level</p>
<p>Establishes the maximum number of iterations to be performed at each
level of the Gaussian pyramid, similar to ANTS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level_iters</strong><span class="classifier">list</span></dt><dd><p>the number of iterations at each level of the Gaussian pyramid.
level_iters[0] corresponds to the finest level, level_iters[n-1]
the coarsest, where n is the length of the list</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id2">
<h3><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace" title="dipy.align.imwarp.ScaleSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imwarp.ScaleSpace">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imwarp.</code><code class="sig-name descname">ScaleSpace</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">num_levels</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">input_spacing=None</em>, <em class="sig-param">sigma_factor=0.2</em>, <em class="sig-param">mask0=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace.get_affine" title="dipy.align.imwarp.ScaleSpace.get_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine</span></code></a>(level)</p></td>
<td><p>Voxel-to-space transformation at a given level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace.get_affine_inv" title="dipy.align.imwarp.ScaleSpace.get_affine_inv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine_inv</span></code></a>(level)</p></td>
<td><p>Space-to-voxel transformation at a given level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace.get_domain_shape" title="dipy.align.imwarp.ScaleSpace.get_domain_shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_domain_shape</span></code></a>(level)</p></td>
<td><p>Shape the sub-sampled image must have at a particular level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace.get_expand_factors" title="dipy.align.imwarp.ScaleSpace.get_expand_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_expand_factors</span></code></a>(from_level, to_level)</p></td>
<td><p>Ratio of voxel size from pyramid level from_level to to_level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace.get_image" title="dipy.align.imwarp.ScaleSpace.get_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_image</span></code></a>(level)</p></td>
<td><p>Smoothed image at a given level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace.get_scaling" title="dipy.align.imwarp.ScaleSpace.get_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_scaling</span></code></a>(level)</p></td>
<td><p>Adjustment factor for input-spacing to reflect voxel sizes at level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace.get_sigmas" title="dipy.align.imwarp.ScaleSpace.get_sigmas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sigmas</span></code></a>(level)</p></td>
<td><p>Smoothing parameters used at a given level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace.get_spacing" title="dipy.align.imwarp.ScaleSpace.get_spacing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_spacing</span></code></a>(level)</p></td>
<td><p>Spacings the sub-sampled image must have at a particular level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.ScaleSpace.print_level" title="dipy.align.imwarp.ScaleSpace.print_level"><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_level</span></code></a>(level)</p></td>
<td><p>Prints properties of a pyramid level</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imwarp.ScaleSpace.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">num_levels</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">input_spacing=None</em>, <em class="sig-param">sigma_factor=0.2</em>, <em class="sig-param">mask0=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>ScaleSpace</p>
<p>Computes the Scale Space representation of an image. The scale space is
simply a list of images produced by smoothing the input image with a
Gaussian kernel with increasing smoothing parameter. If the image’s
voxels are isotropic, the smoothing will be the same along all
directions: at level L = 0, 1, …, the sigma is given by
<span class="math notranslate nohighlight">\(s * ( 2^L - 1 )\)</span>.
If the voxel dimensions are not isotropic, then the smoothing is
weaker along low resolution directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array, shape (r,c) or (s, r, c) where s is the number of</span></dt><dd><p>slices, r is the number of rows and c is the number of columns of
the input image.</p>
</dd>
<dt><strong>num_levels</strong><span class="classifier">int</span></dt><dd><p>the desired number of levels (resolutions) of the scale space</p>
</dd>
<dt><strong>image_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-space transform of the image grid. The default is
the identity matrix</p>
</dd>
<dt><strong>input_spacing</strong><span class="classifier">array, shape (dim,), optional</span></dt><dd><p>the spacing (voxel size) between voxels in physical space. The
default is 1.0 along all axes</p>
</dd>
<dt><strong>sigma_factor</strong><span class="classifier">float, optional</span></dt><dd><p>the smoothing factor to be used in the construction of the scale
space. The default is 0.2</p>
</dd>
<dt><strong>mask0</strong><span class="classifier">Boolean, optional</span></dt><dd><p>if True, all smoothed images will be zero at all voxels that are
zero in the input image. The default is False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.ScaleSpace.get_affine">
<code class="sig-name descname">get_affine</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Voxel-to-space transformation at a given level</p>
<p>Returns the voxel-to-space transformation associated with the
sub-sampled image at a particular resolution of the scale space (note
that this object does not explicitly subsample the smoothed images, but
only provides the properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get affine transform from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the affine (voxel-to-space) transform at the requested resolution</strong></dt><dd><p>or None if an invalid level was requested</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.ScaleSpace.get_affine_inv">
<code class="sig-name descname">get_affine_inv</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace.get_affine_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Space-to-voxel transformation at a given level</p>
<p>Returns the space-to-voxel transformation associated with the
sub-sampled image at a particular resolution of the scale space (note
that this object does not explicitly subsample the smoothed images, but
only provides the properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the inverse transform from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the inverse (space-to-voxel) transform at the requested resolution or</strong></dt><dd></dd>
<dt><strong>None if an invalid level was requested</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.ScaleSpace.get_domain_shape">
<code class="sig-name descname">get_domain_shape</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace.get_domain_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shape the sub-sampled image must have at a particular level</p>
<p>Returns the shape the sub-sampled image must have at a particular
resolution of the scale space (note that this object does not
explicitly subsample the smoothed images, but only provides the
properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the sub-sampled shape from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the sub-sampled shape at the requested resolution or None if an</strong></dt><dd><p>invalid level was requested</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.ScaleSpace.get_expand_factors">
<code class="sig-name descname">get_expand_factors</code><span class="sig-paren">(</span><em class="sig-param">from_level</em>, <em class="sig-param">to_level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace.get_expand_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Ratio of voxel size from pyramid level from_level to to_level</p>
<p>Given two scale space resolutions a = from_level, b = to_level,
returns the ratio of voxels size at level b to voxel size at level a
(the factor that must be used to multiply voxels at level a to
‘expand’ them to level b).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>from_level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the resolution to expand voxels from</p>
</dd>
<dt><strong>to_level</strong><span class="classifier">int, 0 &lt;= to_level &lt; from_level</span></dt><dd><p>the resolution to expand voxels to</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>factors</strong><span class="classifier">array, shape (k,), k = 2, 3</span></dt><dd><p>the expand factors (a scalar for each voxel dimension)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.ScaleSpace.get_image">
<code class="sig-name descname">get_image</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace.get_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothed image at a given level</p>
<p>Returns the smoothed image at the requested level in the Scale Space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the smooth image from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the smooth image at the requested resolution or None if an invalid</strong></dt><dd><p>level was requested</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.ScaleSpace.get_scaling">
<code class="sig-name descname">get_scaling</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace.get_scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjustment factor for input-spacing to reflect voxel sizes at level</p>
<p>Returns the scaling factor that needs to be applied to the input
spacing (the voxel sizes of the image at level 0 of the scale space) to
transform them to voxel sizes at the requested level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the scalings from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the scaling factors from the original spacing to the spacings at the</strong></dt><dd></dd>
<dt><strong>requested level</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.ScaleSpace.get_sigmas">
<code class="sig-name descname">get_sigmas</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace.get_sigmas" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothing parameters used at a given level</p>
<p>Returns the smoothing parameters (a scalar for each axis) used at the
requested level of the scale space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the smoothing parameters from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the smoothing parameters at the requested level</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.ScaleSpace.get_spacing">
<code class="sig-name descname">get_spacing</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace.get_spacing" title="Permalink to this definition">¶</a></dt>
<dd><p>Spacings the sub-sampled image must have at a particular level</p>
<p>Returns the spacings (voxel sizes) the sub-sampled image must have at a
particular resolution of the scale space (note that this object does
not explicitly subsample the smoothed images, but only provides the
properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the sub-sampled shape from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the spacings (voxel sizes) at the requested resolution or None if an</strong></dt><dd></dd>
<dt><strong>invalid level was requested</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.ScaleSpace.print_level">
<code class="sig-name descname">print_level</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.ScaleSpace.print_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints properties of a pyramid level</p>
<p>Prints the properties of a level of this scale space to standard output</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to be printed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="symmetricdiffeomorphicregistration">
<h3><a class="reference internal" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration" title="dipy.align.imwarp.SymmetricDiffeomorphicRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricDiffeomorphicRegistration</span></code></a><a class="headerlink" href="#symmetricdiffeomorphicregistration" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.imwarp.SymmetricDiffeomorphicRegistration">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.imwarp.</code><code class="sig-name descname">SymmetricDiffeomorphicRegistration</code><span class="sig-paren">(</span><em class="sig-param">metric</em>, <em class="sig-param">level_iters=None</em>, <em class="sig-param">step_length=0.25</em>, <em class="sig-param">ss_sigma_factor=0.2</em>, <em class="sig-param">opt_tol=1e-05</em>, <em class="sig-param">inv_iter=20</em>, <em class="sig-param">inv_tol=0.001</em>, <em class="sig-param">callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.imwarp.DiffeomorphicRegistration" title="dipy.align.imwarp.DiffeomorphicRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.imwarp.DiffeomorphicRegistration</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.get_map" title="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.get_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_map</span></code></a>()</p></td>
<td><p>Returns the resulting diffeomorphic map Returns the DiffeomorphicMap registering the moving image towards the static image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.optimize" title="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize</span></code></a>(static, moving[, …])</p></td>
<td><p>Starts the optimization</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_level_iters</span></code>(level_iters)</p></td>
<td><p>Sets the number of iterations at each pyramid level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.update" title="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>(current_displacement, …)</p></td>
<td><p>Composition of the current displacement field with the given field</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">metric</em>, <em class="sig-param">level_iters=None</em>, <em class="sig-param">step_length=0.25</em>, <em class="sig-param">ss_sigma_factor=0.2</em>, <em class="sig-param">opt_tol=1e-05</em>, <em class="sig-param">inv_iter=20</em>, <em class="sig-param">inv_tol=0.001</em>, <em class="sig-param">callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetric Diffeomorphic Registration (SyN) Algorithm</p>
<p>Performs the multi-resolution optimization algorithm for non-linear
registration using a given similarity metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>metric</strong><span class="classifier">SimilarityMetric object</span></dt><dd><p>the metric to be optimized</p>
</dd>
<dt><strong>level_iters</strong><span class="classifier">list of int</span></dt><dd><p>the number of iterations at each level of the Gaussian Pyramid (the
length of the list defines the number of pyramid levels to be
used)</p>
</dd>
<dt><strong>opt_tol</strong><span class="classifier">float</span></dt><dd><p>the optimization will stop when the estimated derivative of the
energy profile w.r.t. time falls below this threshold</p>
</dd>
<dt><strong>inv_iter</strong><span class="classifier">int</span></dt><dd><p>the number of iterations to be performed by the displacement field
inversion algorithm</p>
</dd>
<dt><strong>step_length</strong><span class="classifier">float</span></dt><dd><p>the length of the maximum displacement vector of the update
displacement field at each iteration</p>
</dd>
<dt><strong>ss_sigma_factor</strong><span class="classifier">float</span></dt><dd><p>parameter of the scale-space smoothing kernel. For example, the
std. dev. of the kernel will be factor*(2^i) in the isotropic case
where i = 0, 1, …, n_scales is the scale</p>
</dd>
<dt><strong>inv_tol</strong><span class="classifier">float</span></dt><dd><p>the displacement field inversion algorithm will stop iterating
when the inversion error falls below this threshold</p>
</dd>
<dt><strong>callback</strong><span class="classifier">function(SymmetricDiffeomorphicRegistration)</span></dt><dd><p>a function receiving a SymmetricDiffeomorphicRegistration object
to be called after each iteration (this optimizer will call this
function passing self as parameter)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.get_map">
<code class="sig-name descname">get_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.get_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the resulting diffeomorphic map
Returns the DiffeomorphicMap registering the moving image towards
the static image.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">moving</em>, <em class="sig-param">static_grid2world=None</em>, <em class="sig-param">moving_grid2world=None</em>, <em class="sig-param">prealign=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts the optimization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">array, shape (S, R, C) or (R, C)</span></dt><dd><p>the image to be used as reference during optimization. The
displacement fields will have the same discretization as the static
image.</p>
</dd>
<dt><strong>moving</strong><span class="classifier">array, shape (S, R, C) or (R, C)</span></dt><dd><p>the image to be used as “moving” during optimization. Since the
deformation fields’ discretization is the same as the static image,
it is necessary to pre-align the moving image to ensure its domain
lies inside the domain of the deformation fields. This is assumed
to be accomplished by “pre-aligning” the moving image towards the
static using an affine transformation given by the ‘prealign’
matrix</p>
</dd>
<dt><strong>static_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation associated to the static image</p>
</dd>
<dt><strong>moving_grid2world</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the voxel-to-space transformation associated to the moving image</p>
</dd>
<dt><strong>prealign</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the affine transformation (operating on the physical space)
pre-aligning the moving image towards the static</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>static_to_ref</strong><span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the diffeomorphic map that brings the moving image towards the
static one in the forward direction (i.e. by calling
static_to_ref.transform) and the static image towards the
moving one in the backward direction (i.e. by calling
static_to_ref.transform_inverse).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.imwarp.SymmetricDiffeomorphicRegistration.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">current_displacement</em>, <em class="sig-param">new_displacement</em>, <em class="sig-param">disp_world2grid</em>, <em class="sig-param">time_scaling</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.SymmetricDiffeomorphicRegistration.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Composition of the current displacement field with the given field</p>
<p>Interpolates new displacement at the locations defined by
current_displacement. Equivalently, computes the composition C of the
given displacement fields as C(x) = B(A(x)), where A is
current_displacement and B is new_displacement. This function is
intended to be used with deformation fields of the same sampling
(e.g. to be called by a registration algorithm).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>current_displacement</strong><span class="classifier">array, shape (R’, C’, 2) or (S’, R’, C’, 3)</span></dt><dd><p>the displacement field defining where to interpolate
new_displacement</p>
</dd>
<dt><strong>new_displacement</strong><span class="classifier">array, shape (R, C, 2) or (S, R, C, 3)</span></dt><dd><p>the displacement field to be warped by current_displacement</p>
</dd>
<dt><strong>disp_world2grid</strong><span class="classifier">array, shape (dim+1, dim+1)</span></dt><dd><p>the space-to-grid transform associated with the displacements’
grid (we assume that both displacements are discretized over the
same grid)</p>
</dd>
<dt><strong>time_scaling</strong><span class="classifier">float</span></dt><dd><p>scaling factor applied to d2. The effect may be interpreted as
moving d1 displacements along a factor (<cite>time_scaling</cite>) of d2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>updated</strong><span class="classifier">array, shape (the same as new_displacement)</span></dt><dd><p>the warped displacement field</p>
</dd>
<dt><strong>mean_norm</strong><span class="classifier">the mean norm of all vectors in current_displacement</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id3">
<h3><a class="reference internal" href="#dipy.align.imwarp.floating" title="dipy.align.imwarp.floating"><code class="xref py py-class docutils literal notranslate"><span class="pre">floating</span></code></a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.align.imwarp.floating">
<code class="sig-prename descclassname">dipy.align.imwarp.</code><code class="sig-name descname">floating</code><a class="headerlink" href="#dipy.align.imwarp.floating" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float32</span></code></p>
</dd></dl>

</div>
<div class="section" id="id4">
<h3>get_direction_and_spacings<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imwarp.get_direction_and_spacings">
<code class="sig-prename descclassname">dipy.align.imwarp.</code><code class="sig-name descname">get_direction_and_spacings</code><span class="sig-paren">(</span><em class="sig-param">affine</em>, <em class="sig-param">dim</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.get_direction_and_spacings" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the rotational and spacing components from a matrix</p>
<p>Extracts the rotational and spacing (voxel dimensions) components from a
matrix. An image gradient represents the local variation of the image’s
gray values per voxel. Since we are iterating on the physical space, we
need to compute the gradients as variation per millimeter, so we need to
divide each gradient’s component by the voxel size along the corresponding
axis, that’s what the spacings are used for. Since the image’s gradients
are oriented along the grid axes, we also need to re-orient the gradients
to be given in physical space coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affine</strong><span class="classifier">array, shape (k, k), k = 3, 4</span></dt><dd><p>the matrix transforming grid coordinates to physical space.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>direction</strong><span class="classifier">array, shape (k-1, k-1)</span></dt><dd><p>the rotational component of the input matrix</p>
</dd>
<dt><strong>spacings</strong><span class="classifier">array, shape (k-1,)</span></dt><dd><p>the scaling component (voxel size) of the matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="mult-aff">
<h3>mult_aff<a class="headerlink" href="#mult-aff" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.imwarp.mult_aff">
<code class="sig-prename descclassname">dipy.align.imwarp.</code><code class="sig-name descname">mult_aff</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.imwarp.mult_aff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the matrix product A.dot(B) considering None as the identity</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A</strong><span class="classifier">array, shape (n,k)</span></dt><dd></dd>
<dt><strong>B</strong><span class="classifier">array, shape (k,m)</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>The matrix product A.dot(B). If any of the input matrices is None, it is</strong></dt><dd></dd>
<dt><strong>treated as the identity matrix. If both matrices are None, None is returned</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="ccmetric">
<h3><a class="reference internal" href="#dipy.align.metrics.CCMetric" title="dipy.align.metrics.CCMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">CCMetric</span></code></a><a class="headerlink" href="#ccmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.metrics.CCMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.metrics.</code><code class="sig-name descname">CCMetric</code><span class="sig-paren">(</span><em class="sig-param">dim</em>, <em class="sig-param">sigma_diff=2.0</em>, <em class="sig-param">radius=4</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.metrics.SimilarityMetric" title="dipy.align.metrics.SimilarityMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.metrics.SimilarityMetric</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.CCMetric.compute_backward" title="dipy.align.metrics.CCMetric.compute_backward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_backward</span></code></a>()</p></td>
<td><p>Computes one step bringing the static image towards the moving.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.CCMetric.compute_forward" title="dipy.align.metrics.CCMetric.compute_forward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_forward</span></code></a>()</p></td>
<td><p>Computes one step bringing the moving image towards the static.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.CCMetric.free_iteration" title="dipy.align.metrics.CCMetric.free_iteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">free_iteration</span></code></a>()</p></td>
<td><p>Frees the resources allocated during initialization</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.CCMetric.get_energy" title="dipy.align.metrics.CCMetric.get_energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_energy</span></code></a>()</p></td>
<td><p>Numerical value assigned by this metric to the current image pair</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.CCMetric.initialize_iteration" title="dipy.align.metrics.CCMetric.initialize_iteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_iteration</span></code></a>()</p></td>
<td><p>Prepares the metric to compute one displacement field iteration.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_levels_above</span></code>(levels)</p></td>
<td><p>Informs the metric how many pyramid levels are above the current one</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_levels_below</span></code>(levels)</p></td>
<td><p>Informs the metric how many pyramid levels are below the current one</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_moving_image</span></code>(moving_image, …)</p></td>
<td><p>Sets the moving image being compared against the static one.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_static_image</span></code>(static_image, …)</p></td>
<td><p>Sets the static image being compared against the moving one.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">use_moving_image_dynamics</span></code>(…)</p></td>
<td><p>This is called by the optimizer just after setting the moving image</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">use_static_image_dynamics</span></code>(…)</p></td>
<td><p>This is called by the optimizer just after setting the static image.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.metrics.CCMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">dim</em>, <em class="sig-param">sigma_diff=2.0</em>, <em class="sig-param">radius=4</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalized Cross-Correlation Similarity metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int (either 2 or 3)</span></dt><dd><p>the dimension of the image domain</p>
</dd>
<dt><strong>sigma_diff</strong><span class="classifier">the standard deviation of the Gaussian smoothing kernel to</span></dt><dd><p>be applied to the update field at each iteration</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>the radius of the squared (cubic) neighborhood at each voxel to be
considered to compute the cross correlation</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.CCMetric.compute_backward">
<code class="sig-name descname">compute_backward</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.compute_backward" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes one step bringing the static image towards the moving.</p>
<p>Computes the update displacement field to be used for registration of
the static image towards the moving image</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.CCMetric.compute_forward">
<code class="sig-name descname">compute_forward</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.compute_forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes one step bringing the moving image towards the static.</p>
<p>Computes the update displacement field to be used for registration of
the moving image towards the static image</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.CCMetric.free_iteration">
<code class="sig-name descname">free_iteration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.free_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees the resources allocated during initialization</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.CCMetric.get_energy">
<code class="sig-name descname">get_energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.get_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerical value assigned by this metric to the current image pair</p>
<p>Returns the Cross Correlation (data term) energy computed at the
largest iteration</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.CCMetric.initialize_iteration">
<code class="sig-name descname">initialize_iteration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.CCMetric.initialize_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares the metric to compute one displacement field iteration.</p>
<p>Pre-computes the cross-correlation factors for efficient computation
of the gradient of the Cross Correlation w.r.t. the displacement field.
It also pre-computes the image gradients in the physical space by
re-orienting the gradients in the voxel space using the corresponding
affine transformations.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="emmetric">
<h3><a class="reference internal" href="#dipy.align.metrics.EMMetric" title="dipy.align.metrics.EMMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">EMMetric</span></code></a><a class="headerlink" href="#emmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.metrics.EMMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.metrics.</code><code class="sig-name descname">EMMetric</code><span class="sig-paren">(</span><em class="sig-param">dim</em>, <em class="sig-param">smooth=1.0</em>, <em class="sig-param">inner_iter=5</em>, <em class="sig-param">q_levels=256</em>, <em class="sig-param">double_gradient=True</em>, <em class="sig-param">step_type='gauss_newton'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.metrics.SimilarityMetric" title="dipy.align.metrics.SimilarityMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.metrics.SimilarityMetric</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric.compute_backward" title="dipy.align.metrics.EMMetric.compute_backward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_backward</span></code></a>()</p></td>
<td><p>Computes one step bringing the static image towards the moving.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric.compute_demons_step" title="dipy.align.metrics.EMMetric.compute_demons_step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_demons_step</span></code></a>([forward_step])</p></td>
<td><p>Demons step for EM metric</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric.compute_forward" title="dipy.align.metrics.EMMetric.compute_forward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_forward</span></code></a>()</p></td>
<td><p>Computes one step bringing the reference image towards the static.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric.compute_gauss_newton_step" title="dipy.align.metrics.EMMetric.compute_gauss_newton_step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_gauss_newton_step</span></code></a>([forward_step])</p></td>
<td><p>Computes the Gauss-Newton energy minimization step</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric.free_iteration" title="dipy.align.metrics.EMMetric.free_iteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">free_iteration</span></code></a>()</p></td>
<td><p>Frees the resources allocated during initialization</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric.get_energy" title="dipy.align.metrics.EMMetric.get_energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_energy</span></code></a>()</p></td>
<td><p>The numerical value assigned by this metric to the current image pair</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric.initialize_iteration" title="dipy.align.metrics.EMMetric.initialize_iteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_iteration</span></code></a>()</p></td>
<td><p>Prepares the metric to compute one displacement field iteration.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_levels_above</span></code>(levels)</p></td>
<td><p>Informs the metric how many pyramid levels are above the current one</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_levels_below</span></code>(levels)</p></td>
<td><p>Informs the metric how many pyramid levels are below the current one</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_moving_image</span></code>(moving_image, …)</p></td>
<td><p>Sets the moving image being compared against the static one.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_static_image</span></code>(static_image, …)</p></td>
<td><p>Sets the static image being compared against the moving one.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric.use_moving_image_dynamics" title="dipy.align.metrics.EMMetric.use_moving_image_dynamics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">use_moving_image_dynamics</span></code></a>(…)</p></td>
<td><p>This is called by the optimizer just after setting the moving image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.EMMetric.use_static_image_dynamics" title="dipy.align.metrics.EMMetric.use_static_image_dynamics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">use_static_image_dynamics</span></code></a>(…)</p></td>
<td><p>This is called by the optimizer just after setting the static image.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.metrics.EMMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">dim</em>, <em class="sig-param">smooth=1.0</em>, <em class="sig-param">inner_iter=5</em>, <em class="sig-param">q_levels=256</em>, <em class="sig-param">double_gradient=True</em>, <em class="sig-param">step_type='gauss_newton'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Expectation-Maximization Metric</p>
<p>Similarity metric based on the Expectation-Maximization algorithm to
handle multi-modal images. The transfer function is modeled as a set of
hidden random variables that are estimated at each iteration of the
algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int (either 2 or 3)</span></dt><dd><p>the dimension of the image domain</p>
</dd>
<dt><strong>smooth</strong><span class="classifier">float</span></dt><dd><p>smoothness parameter, the larger the value the smoother the
deformation field</p>
</dd>
<dt><strong>inner_iter</strong><span class="classifier">int</span></dt><dd><p>number of iterations to be performed at each level of the multi-
resolution Gauss-Seidel optimization algorithm (this is not the
number of steps per Gaussian Pyramid level, that parameter must
be set for the optimizer, not the metric)</p>
</dd>
<dt><strong>q_levels</strong><span class="classifier">number of quantization levels (equal to the number of hidden</span></dt><dd><p>variables in the EM algorithm)</p>
</dd>
<dt><strong>double_gradient</strong><span class="classifier">boolean</span></dt><dd><p>if True, the gradient of the expected static image under the moving
modality will be added to the gradient of the moving image,
similarly, the gradient of the expected moving image under the
static modality will be added to the gradient of the static image.</p>
</dd>
<dt><strong>step_type</strong><span class="classifier">string (‘gauss_newton’, ‘demons’)</span></dt><dd><p>the optimization schedule to be used in the multi-resolution
Gauss-Seidel optimization algorithm (not used if Demons Step is
selected)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.EMMetric.compute_backward">
<code class="sig-name descname">compute_backward</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.compute_backward" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes one step bringing the static image towards the moving.</p>
<p>Computes the update displacement field to be used for registration of
the static image towards the moving image</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.EMMetric.compute_demons_step">
<code class="sig-name descname">compute_demons_step</code><span class="sig-paren">(</span><em class="sig-param">forward_step=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.compute_demons_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Demons step for EM metric</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>forward_step</strong><span class="classifier">boolean</span></dt><dd><p>if True, computes the Demons step in the forward direction
(warping the moving towards the static image). If False,
computes the backward step (warping the static image to the
moving image)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>displacement</strong><span class="classifier">array, shape (R, C, 2) or (S, R, C, 3)</span></dt><dd><p>the Demons step</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.EMMetric.compute_forward">
<code class="sig-name descname">compute_forward</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.compute_forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes one step bringing the reference image towards the static.</p>
<p>Computes the forward update field to register the moving image towards
the static image in a gradient-based optimization algorithm</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.EMMetric.compute_gauss_newton_step">
<code class="sig-name descname">compute_gauss_newton_step</code><span class="sig-paren">(</span><em class="sig-param">forward_step=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.compute_gauss_newton_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Gauss-Newton energy minimization step</p>
<p>Computes the Newton step to minimize this energy, i.e., minimizes the
linearized energy function with respect to the
regularized displacement field (this step does not require
post-smoothing, as opposed to the demons step, which does not include
regularization). To accelerate convergence we use the multi-grid
Gauss-Seidel algorithm proposed by Bruhn and Weickert et al [Bruhn05]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>forward_step</strong><span class="classifier">boolean</span></dt><dd><p>if True, computes the Newton step in the forward direction
(warping the moving towards the static image). If False,
computes the backward step (warping the static image to the
moving image)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>displacement</strong><span class="classifier">array, shape (R, C, 2) or (S, R, C, 3)</span></dt><dd><p>the Newton step</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>[Bruhn05] Andres Bruhn and Joachim Weickert, “Towards ultimate motion</dt><dd><p>estimation: combining highest accuracy with real-time
performance”, 10th IEEE International Conference on Computer
Vision, 2005. ICCV 2005.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.EMMetric.free_iteration">
<code class="sig-name descname">free_iteration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.free_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees the resources allocated during initialization</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.EMMetric.get_energy">
<code class="sig-name descname">get_energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.get_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>The numerical value assigned by this metric to the current image pair</p>
<p>Returns the EM (data term) energy computed at the largest
iteration</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.EMMetric.initialize_iteration">
<code class="sig-name descname">initialize_iteration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.initialize_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares the metric to compute one displacement field iteration.</p>
<p>Pre-computes the transfer functions (hidden random variables) and
variances of the estimators. Also pre-computes the gradient of both
input images. Note that once the images are transformed to the opposite
modality, the gradient of the transformed images can be used with the
gradient of the corresponding modality in the same fashion as
diff-demons does for mono-modality images. If the flag
self.use_double_gradient is True these gradients are averaged.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.EMMetric.use_moving_image_dynamics">
<code class="sig-name descname">use_moving_image_dynamics</code><span class="sig-paren">(</span><em class="sig-param">original_moving_image</em>, <em class="sig-param">transformation</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.use_moving_image_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called by the optimizer just after setting the moving image.</p>
<p>EMMetric takes advantage of the image dynamics by computing the
current moving image mask from the original_moving_image mask (warped
by nearest neighbor interpolation)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>original_moving_image</strong><span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>the original moving image from which the current moving image was
generated, the current moving image is the one that was provided
via ‘set_moving_image(…)’, which may not be the same as the
original moving image but a warped version of it.</p>
</dd>
<dt><strong>transformation</strong><span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the transformation that was applied to the original_moving_image
to generate the current moving image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.EMMetric.use_static_image_dynamics">
<code class="sig-name descname">use_static_image_dynamics</code><span class="sig-paren">(</span><em class="sig-param">original_static_image</em>, <em class="sig-param">transformation</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.EMMetric.use_static_image_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called by the optimizer just after setting the static image.</p>
<p>EMMetric takes advantage of the image dynamics by computing the
current static image mask from the originalstaticImage mask (warped
by nearest neighbor interpolation)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>original_static_image</strong><span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>the original static image from which the current static image was
generated, the current static image is the one that was provided
via ‘set_static_image(…)’, which may not be the same as the
original static image but a warped version of it (even the static
image changes during Symmetric Normalization, not only the moving
one).</p>
</dd>
<dt><strong>transformation</strong><span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the transformation that was applied to the original_static_image
to generate the current static image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ssdmetric">
<h3><a class="reference internal" href="#dipy.align.metrics.SSDMetric" title="dipy.align.metrics.SSDMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSDMetric</span></code></a><a class="headerlink" href="#ssdmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.metrics.SSDMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.metrics.</code><code class="sig-name descname">SSDMetric</code><span class="sig-paren">(</span><em class="sig-param">dim</em>, <em class="sig-param">smooth=4</em>, <em class="sig-param">inner_iter=10</em>, <em class="sig-param">step_type='demons'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.metrics.SimilarityMetric" title="dipy.align.metrics.SimilarityMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.metrics.SimilarityMetric</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SSDMetric.compute_backward" title="dipy.align.metrics.SSDMetric.compute_backward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_backward</span></code></a>()</p></td>
<td><p>Computes one step bringing the static image towards the moving.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.SSDMetric.compute_demons_step" title="dipy.align.metrics.SSDMetric.compute_demons_step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_demons_step</span></code></a>([forward_step])</p></td>
<td><p>Demons step for SSD metric</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SSDMetric.compute_forward" title="dipy.align.metrics.SSDMetric.compute_forward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_forward</span></code></a>()</p></td>
<td><p>Computes one step bringing the reference image towards the static.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.SSDMetric.compute_gauss_newton_step" title="dipy.align.metrics.SSDMetric.compute_gauss_newton_step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_gauss_newton_step</span></code></a>([forward_step])</p></td>
<td><p>Computes the Gauss-Newton energy minimization step</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SSDMetric.free_iteration" title="dipy.align.metrics.SSDMetric.free_iteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">free_iteration</span></code></a>()</p></td>
<td><p>Nothing to free for the SSD metric</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.SSDMetric.get_energy" title="dipy.align.metrics.SSDMetric.get_energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_energy</span></code></a>()</p></td>
<td><p>The numerical value assigned by this metric to the current image pair</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SSDMetric.initialize_iteration" title="dipy.align.metrics.SSDMetric.initialize_iteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_iteration</span></code></a>()</p></td>
<td><p>Prepares the metric to compute one displacement field iteration.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_levels_above</span></code>(levels)</p></td>
<td><p>Informs the metric how many pyramid levels are above the current one</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_levels_below</span></code>(levels)</p></td>
<td><p>Informs the metric how many pyramid levels are below the current one</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_moving_image</span></code>(moving_image, …)</p></td>
<td><p>Sets the moving image being compared against the static one.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_static_image</span></code>(static_image, …)</p></td>
<td><p>Sets the static image being compared against the moving one.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">use_moving_image_dynamics</span></code>(…)</p></td>
<td><p>This is called by the optimizer just after setting the moving image</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">use_static_image_dynamics</span></code>(…)</p></td>
<td><p>This is called by the optimizer just after setting the static image.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.metrics.SSDMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">dim</em>, <em class="sig-param">smooth=4</em>, <em class="sig-param">inner_iter=10</em>, <em class="sig-param">step_type='demons'</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of Squared Differences (SSD) Metric</p>
<p>Similarity metric for (mono-modal) nonlinear image registration defined
by the sum of squared differences (SSD)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int (either 2 or 3)</span></dt><dd><p>the dimension of the image domain</p>
</dd>
<dt><strong>smooth</strong><span class="classifier">float</span></dt><dd><p>smoothness parameter, the larger the value the smoother the
deformation field</p>
</dd>
<dt><strong>inner_iter</strong><span class="classifier">int</span></dt><dd><p>number of iterations to be performed at each level of the multi-
resolution Gauss-Seidel optimization algorithm (this is not the
number of steps per Gaussian Pyramid level, that parameter must
be set for the optimizer, not the metric)</p>
</dd>
<dt><strong>step_type</strong><span class="classifier">string</span></dt><dd><p>the displacement field step to be computed when ‘compute_forward’
and ‘compute_backward’ are called. Either ‘demons’ or
‘gauss_newton’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SSDMetric.compute_backward">
<code class="sig-name descname">compute_backward</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.compute_backward" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes one step bringing the static image towards the moving.</p>
<p>Computes the update displacement field to be used for registration of
the static image towards the moving image</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SSDMetric.compute_demons_step">
<code class="sig-name descname">compute_demons_step</code><span class="sig-paren">(</span><em class="sig-param">forward_step=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.compute_demons_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Demons step for SSD metric</p>
<p>Computes the demons step proposed by Vercauteren et al.[Vercauteren09]
for the SSD metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>forward_step</strong><span class="classifier">boolean</span></dt><dd><p>if True, computes the Demons step in the forward direction
(warping the moving towards the static image). If False,
computes the backward step (warping the static image to the
moving image)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>displacement</strong><span class="classifier">array, shape (R, C, 2) or (S, R, C, 3)</span></dt><dd><p>the Demons step</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>[Vercauteren09] Tom Vercauteren, Xavier Pennec, Aymeric Perchant,</dt><dd><p>Nicholas Ayache, “Diffeomorphic Demons: Efficient
Non-parametric Image Registration”, Neuroimage 2009</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SSDMetric.compute_forward">
<code class="sig-name descname">compute_forward</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.compute_forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes one step bringing the reference image towards the static.</p>
<p>Computes the update displacement field to be used for registration of
the moving image towards the static image</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SSDMetric.compute_gauss_newton_step">
<code class="sig-name descname">compute_gauss_newton_step</code><span class="sig-paren">(</span><em class="sig-param">forward_step=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.compute_gauss_newton_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Gauss-Newton energy minimization step</p>
<p>Minimizes the linearized energy function (Newton step) defined by the
sum of squared differences of corresponding pixels of the input images
with respect to the displacement field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>forward_step</strong><span class="classifier">boolean</span></dt><dd><p>if True, computes the Newton step in the forward direction
(warping the moving towards the static image). If False,
computes the backward step (warping the static image to the
moving image)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>displacement</strong><span class="classifier">array, shape = static_image.shape + (3,)</span></dt><dd><p>if forward_step==True, the forward SSD Gauss-Newton step,
else, the backward step</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SSDMetric.free_iteration">
<code class="sig-name descname">free_iteration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.free_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Nothing to free for the SSD metric</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SSDMetric.get_energy">
<code class="sig-name descname">get_energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.get_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>The numerical value assigned by this metric to the current image pair</p>
<p>Returns the Sum of Squared Differences (data term) energy computed at
the largest iteration</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SSDMetric.initialize_iteration">
<code class="sig-name descname">initialize_iteration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SSDMetric.initialize_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares the metric to compute one displacement field iteration.</p>
<p>Pre-computes the gradient of the input images to be used in the
computation of the forward and backward steps.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="similaritymetric">
<h3><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric" title="dipy.align.metrics.SimilarityMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityMetric</span></code></a><a class="headerlink" href="#similaritymetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.metrics.SimilarityMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.metrics.</code><code class="sig-name descname">SimilarityMetric</code><span class="sig-paren">(</span><em class="sig-param">dim</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.compute_backward" title="dipy.align.metrics.SimilarityMetric.compute_backward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_backward</span></code></a>()</p></td>
<td><p>Computes one step bringing the static image towards the moving.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.compute_forward" title="dipy.align.metrics.SimilarityMetric.compute_forward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_forward</span></code></a>()</p></td>
<td><p>Computes one step bringing the reference image towards the static.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.free_iteration" title="dipy.align.metrics.SimilarityMetric.free_iteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">free_iteration</span></code></a>()</p></td>
<td><p>Releases the resources no longer needed by the metric</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.get_energy" title="dipy.align.metrics.SimilarityMetric.get_energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_energy</span></code></a>()</p></td>
<td><p>Numerical value assigned by this metric to the current image pair</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.initialize_iteration" title="dipy.align.metrics.SimilarityMetric.initialize_iteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_iteration</span></code></a>()</p></td>
<td><p>Prepares the metric to compute one displacement field iteration.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.set_levels_above" title="dipy.align.metrics.SimilarityMetric.set_levels_above"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_levels_above</span></code></a>(levels)</p></td>
<td><p>Informs the metric how many pyramid levels are above the current one</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.set_levels_below" title="dipy.align.metrics.SimilarityMetric.set_levels_below"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_levels_below</span></code></a>(levels)</p></td>
<td><p>Informs the metric how many pyramid levels are below the current one</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.set_moving_image" title="dipy.align.metrics.SimilarityMetric.set_moving_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_moving_image</span></code></a>(moving_image, …)</p></td>
<td><p>Sets the moving image being compared against the static one.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.set_static_image" title="dipy.align.metrics.SimilarityMetric.set_static_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_static_image</span></code></a>(static_image, …)</p></td>
<td><p>Sets the static image being compared against the moving one.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.use_moving_image_dynamics" title="dipy.align.metrics.SimilarityMetric.use_moving_image_dynamics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">use_moving_image_dynamics</span></code></a>(…)</p></td>
<td><p>This is called by the optimizer just after setting the moving image</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.metrics.SimilarityMetric.use_static_image_dynamics" title="dipy.align.metrics.SimilarityMetric.use_static_image_dynamics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">use_static_image_dynamics</span></code></a>(…)</p></td>
<td><p>This is called by the optimizer just after setting the static image.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">dim</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Similarity Metric abstract class</p>
<p>A similarity metric is in charge of keeping track of the numerical
value of the similarity (or distance) between the two given images. It
also computes the update field for the forward and inverse displacement
fields to be used in a gradient-based optimization algorithm. Note that
this metric does not depend on any transformation (affine or
non-linear) so it assumes the static and moving images are already
warped</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int (either 2 or 3)</span></dt><dd><p>the dimension of the image domain</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.compute_backward">
<em class="property">abstract </em><code class="sig-name descname">compute_backward</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.compute_backward" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes one step bringing the static image towards the moving.</p>
<p>Computes the backward update field to register the static image towards
the moving image in a gradient-based optimization algorithm</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.compute_forward">
<em class="property">abstract </em><code class="sig-name descname">compute_forward</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.compute_forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes one step bringing the reference image towards the static.</p>
<p>Computes the forward update field to register the moving image towards
the static image in a gradient-based optimization algorithm</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.free_iteration">
<em class="property">abstract </em><code class="sig-name descname">free_iteration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.free_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases the resources no longer needed by the metric</p>
<p>This method is called by the RegistrationOptimizer after the required
iterations have been computed (forward and / or backward) so that the
SimilarityMetric can safely delete any data it computed as part of the
initialization</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.get_energy">
<em class="property">abstract </em><code class="sig-name descname">get_energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.get_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerical value assigned by this metric to the current image pair</p>
<p>Must return the numeric value of the similarity between the given
static and moving images</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.initialize_iteration">
<em class="property">abstract </em><code class="sig-name descname">initialize_iteration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.initialize_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares the metric to compute one displacement field iteration.</p>
<p>This method will be called before any compute_forward or
compute_backward call, this allows the Metric to pre-compute any useful
information for speeding up the update computations. This
initialization was needed in ANTS because the updates are called once
per voxel. In Python this is unpractical, though.</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.set_levels_above">
<code class="sig-name descname">set_levels_above</code><span class="sig-paren">(</span><em class="sig-param">levels</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.set_levels_above" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs the metric how many pyramid levels are above the current one</p>
<p>Informs this metric the number of pyramid levels above the current one.
The metric may change its behavior (e.g. number of inner iterations)
accordingly</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>levels</strong><span class="classifier">int</span></dt><dd><p>the number of levels above the current Gaussian Pyramid level</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.set_levels_below">
<code class="sig-name descname">set_levels_below</code><span class="sig-paren">(</span><em class="sig-param">levels</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.set_levels_below" title="Permalink to this definition">¶</a></dt>
<dd><p>Informs the metric how many pyramid levels are below the current one</p>
<p>Informs this metric the number of pyramid levels below the current one.
The metric may change its behavior (e.g. number of inner iterations)
accordingly</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>levels</strong><span class="classifier">int</span></dt><dd><p>the number of levels below the current Gaussian Pyramid level</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.set_moving_image">
<code class="sig-name descname">set_moving_image</code><span class="sig-paren">(</span><em class="sig-param">moving_image</em>, <em class="sig-param">moving_affine</em>, <em class="sig-param">moving_spacing</em>, <em class="sig-param">moving_direction</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.set_moving_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the moving image being compared against the static one.</p>
<p>Sets the moving image. The default behavior (of this abstract class) is
simply to assign the reference to an attribute, but
generalizations of the metric may need to perform other operations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>moving_image</strong><span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>the moving image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.set_static_image">
<code class="sig-name descname">set_static_image</code><span class="sig-paren">(</span><em class="sig-param">static_image</em>, <em class="sig-param">static_affine</em>, <em class="sig-param">static_spacing</em>, <em class="sig-param">static_direction</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.set_static_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the static image being compared against the moving one.</p>
<p>Sets the static image. The default behavior (of this abstract class) is
simply to assign the reference to an attribute, but
generalizations of the metric may need to perform other operations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static_image</strong><span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>the static image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.use_moving_image_dynamics">
<code class="sig-name descname">use_moving_image_dynamics</code><span class="sig-paren">(</span><em class="sig-param">original_moving_image</em>, <em class="sig-param">transformation</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.use_moving_image_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called by the optimizer just after setting the moving image</p>
<p>This method allows the metric to compute any useful
information from knowing how the current static image was generated
(as the transformation of an original static image). This method is
called by the optimizer just after it sets the static image.
Transformation will be an instance of DiffeomorficMap or None if
the original_moving_image equals self.moving_image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>original_moving_image</strong><span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>original image from which the current moving image was generated</p>
</dd>
<dt><strong>transformation</strong><span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the transformation that was applied to original image to generate
the current moving image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.metrics.SimilarityMetric.use_static_image_dynamics">
<code class="sig-name descname">use_static_image_dynamics</code><span class="sig-paren">(</span><em class="sig-param">original_static_image</em>, <em class="sig-param">transformation</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.SimilarityMetric.use_static_image_dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called by the optimizer just after setting the static image.</p>
<p>This method allows the metric to compute any useful
information from knowing how the current static image was generated
(as the transformation of an original static image). This method is
called by the optimizer just after it sets the static image.
Transformation will be an instance of DiffeomorficMap or None
if the original_static_image equals self.moving_image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>original_static_image</strong><span class="classifier">array, shape (R, C) or (S, R, C)</span></dt><dd><p>original image from which the current static image was generated</p>
</dd>
<dt><strong>transformation</strong><span class="classifier">DiffeomorphicMap object</span></dt><dd><p>the transformation that was applied to original image to generate
the current static image</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id5">
<h3><a class="reference internal" href="#dipy.align.metrics.floating" title="dipy.align.metrics.floating"><code class="xref py py-class docutils literal notranslate"><span class="pre">floating</span></code></a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.align.metrics.floating">
<code class="sig-prename descclassname">dipy.align.metrics.</code><code class="sig-name descname">floating</code><a class="headerlink" href="#dipy.align.metrics.floating" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float32</span></code></p>
</dd></dl>

</div>
<div class="section" id="gradient">
<h3>gradient<a class="headerlink" href="#gradient" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.metrics.gradient">
<code class="sig-prename descclassname">dipy.align.metrics.</code><code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param">f</em>, <em class="sig-param">*varargs</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the gradient of an N-dimensional array.</p>
<p>The gradient is computed using second order accurate central differences
in the interior points and either first or second order accurate one-sides
(forward or backwards) differences at the boundaries.
The returned gradient hence has the same shape as the input array.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>f</strong><span class="classifier">array_like</span></dt><dd><p>An N-dimensional array containing samples of a scalar function.</p>
</dd>
<dt><strong>varargs</strong><span class="classifier">list of scalar or array, optional</span></dt><dd><p>Spacing between f values. Default unitary spacing for all dimensions.
Spacing can be specified using:</p>
<ol class="arabic simple">
<li><p>single scalar to specify a sample distance for all dimensions.</p></li>
<li><p>N scalars to specify a constant sample distance for each dimension.
i.e. <cite>dx</cite>, <cite>dy</cite>, <cite>dz</cite>, …</p></li>
<li><p>N arrays to specify the coordinates of the values along each
dimension of F. The length of the array must match the size of
the corresponding dimension</p></li>
<li><p>Any combination of N scalars/arrays with the meaning of 2. and 3.</p></li>
</ol>
<p>If <cite>axis</cite> is given, the number of varargs must equal the number of axes.
Default: 1.</p>
</dd>
<dt><strong>edge_order</strong><span class="classifier">{1, 2}, optional</span></dt><dd><p>Gradient is calculated using N-th order accurate differences
at the boundaries. Default: 1.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.1.</span></p>
</div>
</dd>
<dt><strong>axis</strong><span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Gradient is calculated only along the given axis or axes
The default (axis = None) is to calculate the gradient for all the axes
of the input array. axis may be negative, in which case it counts from
the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.0.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gradient</strong><span class="classifier">ndarray or list of ndarray</span></dt><dd><p>A set of ndarrays (or a single ndarray if there is only one dimension)
corresponding to the derivatives of f with respect to each dimension.
Each derivative has the same shape as f.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Assuming that <span class="math notranslate nohighlight">\(f\in C^{3}\)</span> (i.e., <span class="math notranslate nohighlight">\(f\)</span> has at least 3 continuous
derivatives) and let <span class="math notranslate nohighlight">\(h_{*}\)</span> be a non-homogeneous stepsize, we
minimize the “consistency error” <span class="math notranslate nohighlight">\(\eta_{i}\)</span> between the true gradient
and its estimate from a linear combination of the neighboring grid-points:</p>
<div class="math notranslate nohighlight">
\[\eta_{i} = f_{i}^{\left(1\right)} -
            \left[ \alpha f\left(x_{i}\right) +
                    \beta f\left(x_{i} + h_{d}\right) +
                    \gamma f\left(x_{i}-h_{s}\right)
            \right]\]</div>
<p>By substituting <span class="math notranslate nohighlight">\(f(x_{i} + h_{d})\)</span> and <span class="math notranslate nohighlight">\(f(x_{i} - h_{s})\)</span>
with their Taylor series expansion, this translates into solving
the following the linear system:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left\{
    \begin{array}{r}
        \alpha+\beta+\gamma=0 \\
        \beta h_{d}-\gamma h_{s}=1 \\
        \beta h_{d}^{2}+\gamma h_{s}^{2}=0
    \end{array}
\right.\end{split}\]</div>
<p>The resulting approximation of <span class="math notranslate nohighlight">\(f_{i}^{(1)}\)</span> is the following:</p>
<div class="math notranslate nohighlight">
\[\hat f_{i}^{(1)} =
    \frac{
        h_{s}^{2}f\left(x_{i} + h_{d}\right)
        + \left(h_{d}^{2} - h_{s}^{2}\right)f\left(x_{i}\right)
        - h_{d}^{2}f\left(x_{i}-h_{s}\right)}
        { h_{s}h_{d}\left(h_{d} + h_{s}\right)}
    + \mathcal{O}\left(\frac{h_{d}h_{s}^{2}
                        + h_{s}h_{d}^{2}}{h_{d}
                        + h_{s}}\right)\]</div>
<p>It is worth noting that if <span class="math notranslate nohighlight">\(h_{s}=h_{d}\)</span>
(i.e., data are evenly spaced)
we find the standard second order approximation:</p>
<div class="math notranslate nohighlight">
\[\hat f_{i}^{(1)}=
    \frac{f\left(x_{i+1}\right) - f\left(x_{i-1}\right)}{2h}
    + \mathcal{O}\left(h^{2}\right)\]</div>
<p>With a similar procedure the forward/backward approximations used for
boundaries can be derived.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb7b40ce2a3e3-1"><span class="brackets"><a class="fn-backref" href="#id6">1</a></span></dt>
<dd><p>Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics
(Texts in Applied Mathematics). New York: Springer.</p>
</dd>
<dt class="label" id="rb7b40ce2a3e3-2"><span class="brackets"><a class="fn-backref" href="#id7">2</a></span></dt>
<dd><p>Durran D. R. (1999) Numerical Methods for Wave Equations
in Geophysical Fluid Dynamics. New York: Springer.</p>
</dd>
<dt class="label" id="rb7b40ce2a3e3-3"><span class="brackets"><a class="fn-backref" href="#id8">3</a></span></dt>
<dd><p>Fornberg B. (1988) Generation of Finite Difference Formulas on
Arbitrarily Spaced Grids,
Mathematics of Computation 51, no. 184 : 699-706.
<a class="reference external" href="http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf">PDF</a>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])</span>
</pre></div>
</div>
<p>Spacing can be also specified with an array that represents the coordinates
of the values F along the dimensions.
For instance a uniform spacing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])</span>
</pre></div>
</div>
<p>Or a non uniform one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1. ,  3. ,  3.5,  6.7,  6.9,  2.5])</span>
</pre></div>
</div>
<p>For two dimensional arrays, the return will be two arrays ordered by
axis. In this example the first array stands for the gradient in
rows and the second one in columns direction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
<span class="go">[array([[ 2.,  2., -1.],</span>
<span class="go">        [ 2.,  2., -1.]]), array([[ 1. ,  2.5,  4. ],</span>
<span class="go">        [ 1. ,  1. ,  1. ]])]</span>
</pre></div>
</div>
<p>In this example the spacing is also specified:
uniform for axis=0 and non uniform for axis=1</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span> <span class="o">=</span> <span class="mf">2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[array([[ 1. ,  1. , -0.5],</span>
<span class="go">        [ 1. ,  1. , -0.5]]), array([[ 2. ,  2. ,  2. ],</span>
<span class="go">        [ 2. ,  1.7,  0.5]])]</span>
</pre></div>
</div>
<p>It is possible to specify how boundaries are treated using <cite>edge_order</cite></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 1.,  2.,  4.,  6.,  7.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([-0.,  2.,  4.,  6.,  8.])</span>
</pre></div>
</div>
<p>The <cite>axis</cite> keyword can be used to specify a subset of axes of which the
gradient is calculated</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 2.,  2., -1.],</span>
<span class="go">       [ 2.,  2., -1.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="v-cycle-2d">
<h3>v_cycle_2d<a class="headerlink" href="#v-cycle-2d" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.metrics.v_cycle_2d">
<code class="sig-prename descclassname">dipy.align.metrics.</code><code class="sig-name descname">v_cycle_2d</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">k</em>, <em class="sig-param">delta_field</em>, <em class="sig-param">sigma_sq_field</em>, <em class="sig-param">gradient_field</em>, <em class="sig-param">target</em>, <em class="sig-param">lambda_param</em>, <em class="sig-param">displacement</em>, <em class="sig-param">depth=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.v_cycle_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-resolution Gauss-Seidel solver using V-type cycles</p>
<p>Multi-resolution Gauss-Seidel solver: solves the Gauss-Newton linear system
by first filtering (GS-iterate) the current level, then solves for the
residual at a coarser resolution and finally refines the solution at the
current resolution. This scheme corresponds to the V-cycle proposed by
Bruhn and Weickert[Bruhn05].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>number of levels of the multi-resolution algorithm (it will be called
recursively until level n == 0)</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>the number of iterations at each multi-resolution level</p>
</dd>
<dt><strong>delta_field</strong><span class="classifier">array, shape (R, C)</span></dt><dd><p>the difference between the static and moving image (the ‘derivative
w.r.t. time’ in the optical flow model)</p>
</dd>
<dt><strong>sigma_sq_field</strong><span class="classifier">array, shape (R, C)</span></dt><dd><p>the variance of the gray level value at each voxel, according to the
EM model (for SSD, it is 1 for all voxels). Inf and 0 values
are processed specially to support infinite and zero variance.</p>
</dd>
<dt><strong>gradient_field</strong><span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt><strong>target</strong><span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>right-hand side of the linear system to be solved in the Weickert’s
multi-resolution algorithm</p>
</dd>
<dt><strong>lambda_param</strong><span class="classifier">float</span></dt><dd><p>smoothness parameter, the larger its value the smoother the
displacement field</p>
</dd>
<dt><strong>displacement</strong><span class="classifier">array, shape (R, C, 2)</span></dt><dd><p>the displacement field to start the optimization from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>energy</strong><span class="classifier">the energy of the EM (or SSD if sigmafield[…]==1) metric at this</span></dt><dd><p>iteration</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="simple">
<dt>[Bruhn05] Andres Bruhn and Joachim Weickert, “Towards ultimate motion</dt><dd><p>estimation: combining highest accuracy with real-time
performance”, 10th IEEE International Conference on Computer
Vision, 2005. ICCV 2005.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="v-cycle-3d">
<h3>v_cycle_3d<a class="headerlink" href="#v-cycle-3d" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.metrics.v_cycle_3d">
<code class="sig-prename descclassname">dipy.align.metrics.</code><code class="sig-name descname">v_cycle_3d</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">k</em>, <em class="sig-param">delta_field</em>, <em class="sig-param">sigma_sq_field</em>, <em class="sig-param">gradient_field</em>, <em class="sig-param">target</em>, <em class="sig-param">lambda_param</em>, <em class="sig-param">displacement</em>, <em class="sig-param">depth=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.metrics.v_cycle_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-resolution Gauss-Seidel solver using V-type cycles</p>
<p>Multi-resolution Gauss-Seidel solver: solves the linear system by first
filtering (GS-iterate) the current level, then solves for the residual
at a coarser resolution and finally refines the solution at the current
resolution. This scheme corresponds to the V-cycle proposed by Bruhn and
Weickert[1].
[1] Andres Bruhn and Joachim Weickert, “Towards ultimate motion estimation:</p>
<blockquote>
<div><p>combining highest accuracy with real-time performance”,
10th IEEE International Conference on Computer Vision, 2005.
ICCV 2005.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>number of levels of the multi-resolution algorithm (it will be called
recursively until level n == 0)</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>the number of iterations at each multi-resolution level</p>
</dd>
<dt><strong>delta_field</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the difference between the static and moving image (the ‘derivative
w.r.t. time’ in the optical flow model)</p>
</dd>
<dt><strong>sigma_sq_field</strong><span class="classifier">array, shape (S, R, C)</span></dt><dd><p>the variance of the gray level value at each voxel, according to the
EM model (for SSD, it is 1 for all voxels). Inf and 0 values
are processed specially to support infinite and zero variance.</p>
</dd>
<dt><strong>gradient_field</strong><span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the gradient of the moving image</p>
</dd>
<dt><strong>target</strong><span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>right-hand side of the linear system to be solved in the Weickert’s
multi-resolution algorithm</p>
</dd>
<dt><strong>lambda_param</strong><span class="classifier">float</span></dt><dd><p>smoothness parameter, the larger its value the smoother the
displacement field</p>
</dd>
<dt><strong>displacement</strong><span class="classifier">array, shape (S, R, C, 3)</span></dt><dd><p>the displacement field to start the optimization from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>energy</strong><span class="classifier">the energy of the EM (or SSD if sigmafield[…]==1) metric at this</span></dt><dd><p>iteration</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="pool">
<h3>Pool<a class="headerlink" href="#pool" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.reslice.Pool">
<code class="sig-prename descclassname">dipy.align.reslice.</code><code class="sig-name descname">Pool</code><span class="sig-paren">(</span><em class="sig-param">processes=None</em>, <em class="sig-param">initializer=None</em>, <em class="sig-param">initargs=()</em>, <em class="sig-param">maxtasksperchild=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.reslice.Pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a process pool object</p>
</dd></dl>

</div>
<div class="section" id="affine-transform">
<h3>affine_transform<a class="headerlink" href="#affine-transform" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.reslice.affine_transform">
<code class="sig-prename descclassname">dipy.align.reslice.</code><code class="sig-name descname">affine_transform</code><span class="sig-paren">(</span><em class="sig-param">input</em>, <em class="sig-param">matrix</em>, <em class="sig-param">offset=0.0</em>, <em class="sig-param">output_shape=None</em>, <em class="sig-param">output=None</em>, <em class="sig-param">order=3</em>, <em class="sig-param">mode='constant'</em>, <em class="sig-param">cval=0.0</em>, <em class="sig-param">prefilter=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.reslice.affine_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply an affine transformation.</p>
<p>Given an output image pixel index vector <code class="docutils literal notranslate"><span class="pre">o</span></code>, the pixel value
is determined from the input image at position
<code class="docutils literal notranslate"><span class="pre">np.dot(matrix,</span> <span class="pre">o)</span> <span class="pre">+</span> <span class="pre">offset</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>input</strong><span class="classifier">array_like</span></dt><dd><p>The input array.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">ndarray</span></dt><dd><p>The inverse coordinate transformation matrix, mapping output
coordinates to input coordinates. If <code class="docutils literal notranslate"><span class="pre">ndim</span></code> is the number of
dimensions of <code class="docutils literal notranslate"><span class="pre">input</span></code>, the given matrix must have one of the
following shapes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(ndim,</span> <span class="pre">ndim)</span></code>: the linear transformation matrix for each
output coordinate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(ndim,)</span></code>: assume that the 2D transformation matrix is
diagonal, with the diagonal specified by the given value. A more
efficient algorithm is then used that exploits the separability
of the problem.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(ndim</span> <span class="pre">+</span> <span class="pre">1,</span> <span class="pre">ndim</span> <span class="pre">+</span> <span class="pre">1)</span></code>: assume that the transformation is
specified using homogeneous coordinates <a class="reference internal" href="#re543e1a22138-1" id="id9">[1]</a>. In this case, any
value passed to <code class="docutils literal notranslate"><span class="pre">offset</span></code> is ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(ndim,</span> <span class="pre">ndim</span> <span class="pre">+</span> <span class="pre">1)</span></code>: as above, but the bottom row of a
homogeneous transformation matrix is always <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">...,</span> <span class="pre">1]</span></code>,
and may be omitted.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>offset</strong><span class="classifier">float or sequence, optional</span></dt><dd><p>The offset into the array where the transform is applied. If a float,
<cite>offset</cite> is the same for each axis. If a sequence, <cite>offset</cite> should
contain one value for each axis.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple of ints, optional</span></dt><dd><p>Shape tuple.</p>
</dd>
<dt><strong>output</strong><span class="classifier">array or dtype, optional</span></dt><dd><p>The array in which to place the output, or the dtype of the
returned array. By default an array of the same dtype as input
will be created.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 3.
The order has to be in the range 0-5.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional</span></dt><dd><p>The <cite>mode</cite> parameter determines how the input array is extended
when the filter overlaps a border. Default is ‘reflect’. Behavior
for each valid value is as follows:</p>
<dl class="simple">
<dt>‘reflect’ (<cite>d c b a | a b c d | d c b a</cite>)</dt><dd><p>The input is extended by reflecting about the edge of the last
pixel.</p>
</dd>
<dt>‘constant’ (<cite>k k k k | a b c d | k k k k</cite>)</dt><dd><p>The input is extended by filling all values beyond the edge with
the same constant value, defined by the <cite>cval</cite> parameter.</p>
</dd>
<dt>‘nearest’ (<cite>a a a a | a b c d | d d d d</cite>)</dt><dd><p>The input is extended by replicating the last pixel.</p>
</dd>
<dt>‘mirror’ (<cite>d c b | a b c d | c b a</cite>)</dt><dd><p>The input is extended by reflecting about the center of the last
pixel.</p>
</dd>
<dt>‘wrap’ (<cite>a b c d | a b c d | a b c d</cite>)</dt><dd><p>The input is extended by wrapping around to the opposite edge.</p>
</dd>
</dl>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <cite>mode</cite> is ‘constant’. Default
is 0.0.</p>
</dd>
<dt><strong>prefilter</strong><span class="classifier">bool, optional</span></dt><dd><p>Determines if the input array is prefiltered with <cite>spline_filter</cite>
before interpolation. The default is True, which will create a
temporary <cite>float64</cite> array of filtered values if <cite>order &gt; 1</cite>. If
setting this to False, the output will be slightly blurred if
<cite>order &gt; 1</cite>, unless the input is prefiltered, i.e. it is the result
of calling <cite>spline_filter</cite> on the original input.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>affine_transform</strong><span class="classifier">ndarray</span></dt><dd><p>The transformed input.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The given matrix and offset are used to find for each point in the
output the corresponding coordinates in the input by an affine
transformation. The value of the input at those coordinates is
determined by spline interpolation of the requested order. Points
outside the boundaries of the input are filled according to the given
mode.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.0: </span>Previously, the exact interpretation of the affine transformation
depended on whether the matrix was supplied as a one-dimensional or
two-dimensional array. If a one-dimensional array was supplied
to the matrix parameter, the output pixel value at index <code class="docutils literal notranslate"><span class="pre">o</span></code>
was determined from the input image at position
<code class="docutils literal notranslate"><span class="pre">matrix</span> <span class="pre">*</span> <span class="pre">(o</span> <span class="pre">+</span> <span class="pre">offset)</span></code>.</p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re543e1a22138-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id9">1</a>,<a href="#id10">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">https://en.wikipedia.org/wiki/Homogeneous_coordinates</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="cpu-count">
<h3>cpu_count<a class="headerlink" href="#cpu-count" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.reslice.cpu_count">
<code class="sig-prename descclassname">dipy.align.reslice.</code><code class="sig-name descname">cpu_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.reslice.cpu_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of CPUs in the system</p>
</dd></dl>

</div>
<div class="section" id="reslice">
<h3>reslice<a class="headerlink" href="#reslice" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.reslice.reslice">
<code class="sig-prename descclassname">dipy.align.reslice.</code><code class="sig-name descname">reslice</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">affine</em>, <em class="sig-param">zooms</em>, <em class="sig-param">new_zooms</em>, <em class="sig-param">order=1</em>, <em class="sig-param">mode='constant'</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">num_processes=1</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.reslice.reslice" title="Permalink to this definition">¶</a></dt>
<dd><p>Reslice data with new voxel resolution defined by <code class="docutils literal notranslate"><span class="pre">new_zooms</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array, shape (I,J,K) or (I,J,K,N)</span></dt><dd><p>3d volume or 4d volume with datasets</p>
</dd>
<dt><strong>affine</strong><span class="classifier">array, shape (4,4)</span></dt><dd><p>mapping from voxel coordinates to world coordinates</p>
</dd>
<dt><strong>zooms</strong><span class="classifier">tuple, shape (3,)</span></dt><dd><p>voxel size for (i,j,k) dimensions</p>
</dd>
<dt><strong>new_zooms</strong><span class="classifier">tuple, shape (3,)</span></dt><dd><p>new voxel size for (i,j,k) after resampling</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, from 0 to 5</span></dt><dd><p>order of interpolation for resampling/reslicing,
0 nearest interpolation, 1 trilinear etc..
if you don’t want any smoothing 0 is the option you need.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string (‘constant’, ‘nearest’, ‘reflect’ or ‘wrap’)</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float</span></dt><dd><p>Value used for points outside the boundaries of the input if
mode=’constant’.</p>
</dd>
<dt><strong>num_processes</strong><span class="classifier">int</span></dt><dd><p>Split the calculation to a pool of children processes. This only
applies to 4D <cite>data</cite> arrays. If a positive integer then it defines
the size of the multiprocessing pool that will be used. If 0, then
the size of the pool will equal the number of cores available.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data2</strong><span class="classifier">array, shape (I,J,K) or (I,J,K,N)</span></dt><dd><p>datasets resampled into isotropic voxel size</p>
</dd>
<dt><strong>affine2</strong><span class="classifier">array, shape (4,4)</span></dt><dd><p>new affine for the resampled image</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.align.reslice</span> <span class="k">import</span> <span class="n">reslice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.data</span> <span class="k">import</span> <span class="n">get_fnames</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fimg</span> <span class="o">=</span> <span class="n">get_fnames</span><span class="p">(</span><span class="s1">&#39;aniso_vox&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fimg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">58</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">affine</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">affine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zooms</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">()[:</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zooms</span>
<span class="go">(4.0, 4.0, 5.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_zooms</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">3.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_zooms</span>
<span class="go">(3.0, 3.0, 3.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data2</span><span class="p">,</span> <span class="n">affine2</span> <span class="o">=</span> <span class="n">reslice</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">zooms</span><span class="p">,</span> <span class="n">new_zooms</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data2</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="id11">
<h3><a class="reference internal" href="#dipy.align.scalespace.IsotropicScaleSpace" title="dipy.align.scalespace.IsotropicScaleSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">IsotropicScaleSpace</span></code></a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.scalespace.IsotropicScaleSpace">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.scalespace.</code><code class="sig-name descname">IsotropicScaleSpace</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">factors</em>, <em class="sig-param">sigmas</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">input_spacing=None</em>, <em class="sig-param">mask0=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.IsotropicScaleSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.scalespace.ScaleSpace" title="dipy.align.scalespace.ScaleSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.scalespace.ScaleSpace</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine</span></code>(level)</p></td>
<td><p>Voxel-to-space transformation at a given level</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine_inv</span></code>(level)</p></td>
<td><p>Space-to-voxel transformation at a given level</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_domain_shape</span></code>(level)</p></td>
<td><p>Shape the sub-sampled image must have at a particular level</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_expand_factors</span></code>(from_level, to_level)</p></td>
<td><p>Ratio of voxel size from pyramid level from_level to to_level</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_image</span></code>(level)</p></td>
<td><p>Smoothed image at a given level</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_scaling</span></code>(level)</p></td>
<td><p>Adjustment factor for input-spacing to reflect voxel sizes at level</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sigmas</span></code>(level)</p></td>
<td><p>Smoothing parameters used at a given level</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_spacing</span></code>(level)</p></td>
<td><p>Spacings the sub-sampled image must have at a particular level</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_level</span></code>(level)</p></td>
<td><p>Prints properties of a pyramid level</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.scalespace.IsotropicScaleSpace.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">factors</em>, <em class="sig-param">sigmas</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">input_spacing=None</em>, <em class="sig-param">mask0=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.IsotropicScaleSpace.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>IsotropicScaleSpace</p>
<p>Computes the Scale Space representation of an image using isotropic
smoothing kernels for all scales. The scale space is simply a list
of images produced by smoothing the input image with a Gaussian
kernel with different smoothing parameters.</p>
<p>This specialization of ScaleSpace allows the user to provide custom
scale and smoothing factors for all scales.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array, shape (r,c) or (s, r, c) where s is the number of</span></dt><dd><p>slices, r is the number of rows and c is the number of columns of
the input image.</p>
</dd>
<dt><strong>factors</strong><span class="classifier">list of floats</span></dt><dd><p>custom scale factors to build the scale space (one factor for each
scale).</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">list of floats</span></dt><dd><p>custom smoothing parameter to build the scale space (one parameter
for each scale).</p>
</dd>
<dt><strong>image_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-space transform of the image grid. The default is
the identity matrix.</p>
</dd>
<dt><strong>input_spacing</strong><span class="classifier">array, shape (dim,), optional</span></dt><dd><p>the spacing (voxel size) between voxels in physical space. The
default if 1.0 along all axes.</p>
</dd>
<dt><strong>mask0</strong><span class="classifier">Boolean, optional</span></dt><dd><p>if True, all smoothed images will be zero at all voxels that are
zero in the input image. The default is False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id12">
<h3><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace" title="dipy.align.scalespace.ScaleSpace"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScaleSpace</span></code></a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.scalespace.ScaleSpace">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.scalespace.</code><code class="sig-name descname">ScaleSpace</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">num_levels</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">input_spacing=None</em>, <em class="sig-param">sigma_factor=0.2</em>, <em class="sig-param">mask0=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace.get_affine" title="dipy.align.scalespace.ScaleSpace.get_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine</span></code></a>(level)</p></td>
<td><p>Voxel-to-space transformation at a given level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace.get_affine_inv" title="dipy.align.scalespace.ScaleSpace.get_affine_inv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_affine_inv</span></code></a>(level)</p></td>
<td><p>Space-to-voxel transformation at a given level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace.get_domain_shape" title="dipy.align.scalespace.ScaleSpace.get_domain_shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_domain_shape</span></code></a>(level)</p></td>
<td><p>Shape the sub-sampled image must have at a particular level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace.get_expand_factors" title="dipy.align.scalespace.ScaleSpace.get_expand_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_expand_factors</span></code></a>(from_level, to_level)</p></td>
<td><p>Ratio of voxel size from pyramid level from_level to to_level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace.get_image" title="dipy.align.scalespace.ScaleSpace.get_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_image</span></code></a>(level)</p></td>
<td><p>Smoothed image at a given level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace.get_scaling" title="dipy.align.scalespace.ScaleSpace.get_scaling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_scaling</span></code></a>(level)</p></td>
<td><p>Adjustment factor for input-spacing to reflect voxel sizes at level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace.get_sigmas" title="dipy.align.scalespace.ScaleSpace.get_sigmas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sigmas</span></code></a>(level)</p></td>
<td><p>Smoothing parameters used at a given level</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace.get_spacing" title="dipy.align.scalespace.ScaleSpace.get_spacing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_spacing</span></code></a>(level)</p></td>
<td><p>Spacings the sub-sampled image must have at a particular level</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.scalespace.ScaleSpace.print_level" title="dipy.align.scalespace.ScaleSpace.print_level"><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_level</span></code></a>(level)</p></td>
<td><p>Prints properties of a pyramid level</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.scalespace.ScaleSpace.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">num_levels</em>, <em class="sig-param">image_grid2world=None</em>, <em class="sig-param">input_spacing=None</em>, <em class="sig-param">sigma_factor=0.2</em>, <em class="sig-param">mask0=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>ScaleSpace</p>
<p>Computes the Scale Space representation of an image. The scale space is
simply a list of images produced by smoothing the input image with a
Gaussian kernel with increasing smoothing parameter. If the image’s
voxels are isotropic, the smoothing will be the same along all
directions: at level L = 0, 1, …, the sigma is given by
<span class="math notranslate nohighlight">\(s * ( 2^L - 1 )\)</span>.
If the voxel dimensions are not isotropic, then the smoothing is
weaker along low resolution directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array, shape (r,c) or (s, r, c) where s is the number of</span></dt><dd><p>slices, r is the number of rows and c is the number of columns of
the input image.</p>
</dd>
<dt><strong>num_levels</strong><span class="classifier">int</span></dt><dd><p>the desired number of levels (resolutions) of the scale space</p>
</dd>
<dt><strong>image_grid2world</strong><span class="classifier">array, shape (dim + 1, dim + 1), optional</span></dt><dd><p>the grid-to-space transform of the image grid. The default is
the identity matrix</p>
</dd>
<dt><strong>input_spacing</strong><span class="classifier">array, shape (dim,), optional</span></dt><dd><p>the spacing (voxel size) between voxels in physical space. The
default is 1.0 along all axes</p>
</dd>
<dt><strong>sigma_factor</strong><span class="classifier">float, optional</span></dt><dd><p>the smoothing factor to be used in the construction of the scale
space. The default is 0.2</p>
</dd>
<dt><strong>mask0</strong><span class="classifier">Boolean, optional</span></dt><dd><p>if True, all smoothed images will be zero at all voxels that are
zero in the input image. The default is False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.scalespace.ScaleSpace.get_affine">
<code class="sig-name descname">get_affine</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Voxel-to-space transformation at a given level</p>
<p>Returns the voxel-to-space transformation associated with the
sub-sampled image at a particular resolution of the scale space (note
that this object does not explicitly subsample the smoothed images, but
only provides the properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get affine transform from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the affine (voxel-to-space) transform at the requested resolution</strong></dt><dd><p>or None if an invalid level was requested</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.scalespace.ScaleSpace.get_affine_inv">
<code class="sig-name descname">get_affine_inv</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_affine_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Space-to-voxel transformation at a given level</p>
<p>Returns the space-to-voxel transformation associated with the
sub-sampled image at a particular resolution of the scale space (note
that this object does not explicitly subsample the smoothed images, but
only provides the properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the inverse transform from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the inverse (space-to-voxel) transform at the requested resolution or</strong></dt><dd></dd>
<dt><strong>None if an invalid level was requested</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.scalespace.ScaleSpace.get_domain_shape">
<code class="sig-name descname">get_domain_shape</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_domain_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shape the sub-sampled image must have at a particular level</p>
<p>Returns the shape the sub-sampled image must have at a particular
resolution of the scale space (note that this object does not
explicitly subsample the smoothed images, but only provides the
properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the sub-sampled shape from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the sub-sampled shape at the requested resolution or None if an</strong></dt><dd><p>invalid level was requested</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.scalespace.ScaleSpace.get_expand_factors">
<code class="sig-name descname">get_expand_factors</code><span class="sig-paren">(</span><em class="sig-param">from_level</em>, <em class="sig-param">to_level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_expand_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Ratio of voxel size from pyramid level from_level to to_level</p>
<p>Given two scale space resolutions a = from_level, b = to_level,
returns the ratio of voxels size at level b to voxel size at level a
(the factor that must be used to multiply voxels at level a to
‘expand’ them to level b).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>from_level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the resolution to expand voxels from</p>
</dd>
<dt><strong>to_level</strong><span class="classifier">int, 0 &lt;= to_level &lt; from_level</span></dt><dd><p>the resolution to expand voxels to</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>factors</strong><span class="classifier">array, shape (k,), k = 2, 3</span></dt><dd><p>the expand factors (a scalar for each voxel dimension)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.scalespace.ScaleSpace.get_image">
<code class="sig-name descname">get_image</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothed image at a given level</p>
<p>Returns the smoothed image at the requested level in the Scale Space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the smooth image from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the smooth image at the requested resolution or None if an invalid</strong></dt><dd><p>level was requested</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.scalespace.ScaleSpace.get_scaling">
<code class="sig-name descname">get_scaling</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjustment factor for input-spacing to reflect voxel sizes at level</p>
<p>Returns the scaling factor that needs to be applied to the input
spacing (the voxel sizes of the image at level 0 of the scale space) to
transform them to voxel sizes at the requested level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the scalings from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the scaling factors from the original spacing to the spacings at the</strong></dt><dd></dd>
<dt><strong>requested level</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.scalespace.ScaleSpace.get_sigmas">
<code class="sig-name descname">get_sigmas</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_sigmas" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothing parameters used at a given level</p>
<p>Returns the smoothing parameters (a scalar for each axis) used at the
requested level of the scale space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the smoothing parameters from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the smoothing parameters at the requested level</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.scalespace.ScaleSpace.get_spacing">
<code class="sig-name descname">get_spacing</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.get_spacing" title="Permalink to this definition">¶</a></dt>
<dd><p>Spacings the sub-sampled image must have at a particular level</p>
<p>Returns the spacings (voxel sizes) the sub-sampled image must have at a
particular resolution of the scale space (note that this object does
not explicitly subsample the smoothed images, but only provides the
properties the sub-sampled images must have).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to get the sub-sampled shape from</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>the spacings (voxel sizes) at the requested resolution or None if an</strong></dt><dd></dd>
<dt><strong>invalid level was requested</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.scalespace.ScaleSpace.print_level">
<code class="sig-name descname">print_level</code><span class="sig-paren">(</span><em class="sig-param">level</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.scalespace.ScaleSpace.print_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints properties of a pyramid level</p>
<p>Prints the properties of a level of this scale space to standard output</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int, 0 &lt;= from_level &lt; L, (L = number of resolutions)</span></dt><dd><p>the scale space level to be printed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id13">
<h3><a class="reference internal" href="#dipy.align.scalespace.floating" title="dipy.align.scalespace.floating"><code class="xref py py-class docutils literal notranslate"><span class="pre">floating</span></code></a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.align.scalespace.floating">
<code class="sig-prename descclassname">dipy.align.scalespace.</code><code class="sig-name descname">floating</code><a class="headerlink" href="#dipy.align.scalespace.floating" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.float32</span></code></p>
</dd></dl>

</div>
<div class="section" id="bundlemindistanceasymmetricmetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric" title="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceAsymmetricMetric</span></code></a><a class="headerlink" href="#bundlemindistanceasymmetricmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">BundleMinDistanceAsymmetricMetric</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMetric" title="dipy.align.streamlinear.BundleMinDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.streamlinear.BundleMinDistanceMetric</span></code></a></p>
<p>Asymmetric Bundle-based Minimum distance</p>
<p>This is a cost function that can be used by the
StreamlineLinearRegistration class.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.distance" title="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code></a>(xopt)</p></td>
<td><p>Distance calculated from this Metric</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setup</span></code>(static, moving)</p></td>
<td><p>Setup static and moving sets of streamlines</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for the metric used for streamline registration</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.distance">
<code class="sig-name descname">distance</code><span class="sig-paren">(</span><em class="sig-param">xopt</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceAsymmetricMetric.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance calculated from this Metric</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xopt</strong><span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bundlemindistancematrixmetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric" title="dipy.align.streamlinear.BundleMinDistanceMatrixMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMatrixMetric</span></code></a><a class="headerlink" href="#bundlemindistancematrixmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.streamlinear.BundleMinDistanceMatrixMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">BundleMinDistanceMatrixMetric</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="dipy.align.streamlinear.StreamlineDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.streamlinear.StreamlineDistanceMetric</span></code></a></p>
<p>Bundle-based Minimum Distance aka BMD</p>
<p>This is the cost function used by the StreamlineLinearRegistration</p>
<p class="rubric">Notes</p>
<p>The difference with BundleMinDistanceMetric is that this creates
the entire distance matrix and therefore requires more memory.</p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>setup(static, moving)</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>distance(xopt)</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.streamlinear.BundleMinDistanceMatrixMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for the metric used for streamline registration</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.BundleMinDistanceMatrixMetric.distance">
<code class="sig-name descname">distance</code><span class="sig-paren">(</span><em class="sig-param">xopt</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance calculated from this Metric</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xopt</strong><span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.BundleMinDistanceMatrixMetric.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">moving</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup static and moving sets of streamlines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">streamlines</span></dt><dd><p>Fixed or reference set of streamlines.</p>
</dd>
<dt><strong>moving</strong><span class="classifier">streamlines</span></dt><dd><p>Moving streamlines.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Call this after the object is initiated and before distance.</p>
<p>Num_threads is not used in this class. Use <code class="docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code>
for a faster, threaded and less memory hungry metric</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bundlemindistancemetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMetric" title="dipy.align.streamlinear.BundleMinDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleMinDistanceMetric</span></code></a><a class="headerlink" href="#bundlemindistancemetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.streamlinear.BundleMinDistanceMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">BundleMinDistanceMetric</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="dipy.align.streamlinear.StreamlineDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.streamlinear.StreamlineDistanceMetric</span></code></a></p>
<p>Bundle-based Minimum Distance aka BMD</p>
<p>This is the cost function used by the StreamlineLinearRegistration</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra052abf06f20-garyfallidis14"><span class="brackets"><a class="fn-backref" href="#id14">Garyfallidis14</a></span></dt>
<dd><p>Garyfallidis et al., “Direct native-space fiber
bundle alignment for group comparisons”, ISMRM,
2014.</p>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>setup(static, moving)</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>distance(xopt)</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.streamlinear.BundleMinDistanceMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for the metric used for streamline registration</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.BundleMinDistanceMetric.distance">
<code class="sig-name descname">distance</code><span class="sig-paren">(</span><em class="sig-param">xopt</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMetric.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance calculated from this Metric</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xopt</strong><span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector,</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.BundleMinDistanceMetric.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">moving</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleMinDistanceMetric.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup static and moving sets of streamlines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">streamlines</span></dt><dd><p>Fixed or reference set of streamlines.</p>
</dd>
<dt><strong>moving</strong><span class="classifier">streamlines</span></dt><dd><p>Moving streamlines.</p>
</dd>
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Call this after the object is initiated and before distance.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bundlesumdistancematrixmetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric" title="dipy.align.streamlinear.BundleSumDistanceMatrixMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">BundleSumDistanceMatrixMetric</span></code></a><a class="headerlink" href="#bundlesumdistancematrixmetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.streamlinear.BundleSumDistanceMatrixMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">BundleSumDistanceMatrixMetric</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#dipy.align.streamlinear.BundleMinDistanceMatrixMetric" title="dipy.align.streamlinear.BundleMinDistanceMatrixMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.align.streamlinear.BundleMinDistanceMatrixMetric</span></code></a></p>
<p>Bundle-based Sum Distance aka BMD</p>
<p>This is a cost function that can be used by the
StreamlineLinearRegistration class.</p>
<p class="rubric">Notes</p>
<p>The difference with BundleMinDistanceMatrixMetric is that it uses
uses the sum of the distance matrix and not the sum of mins.</p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>setup(static, moving)</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>distance(xopt)</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.streamlinear.BundleSumDistanceMatrixMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for the metric used for streamline registration</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.BundleSumDistanceMatrixMetric.distance">
<code class="sig-name descname">distance</code><span class="sig-paren">(</span><em class="sig-param">xopt</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.BundleSumDistanceMatrixMetric.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Distance calculated from this Metric</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xopt</strong><span class="classifier">sequence</span></dt><dd><p>List of affine parameters as an 1D vector</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id15">
<h3><a class="reference internal" href="#dipy.align.streamlinear.Optimizer" title="dipy.align.streamlinear.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Optimizer</span></code></a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.streamlinear.Optimizer">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">Optimizer</code><span class="sig-paren">(</span><em class="sig-param">fun</em>, <em class="sig-param">x0</em>, <em class="sig-param">args=()</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">jac=None</em>, <em class="sig-param">hess=None</em>, <em class="sig-param">hessp=None</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">constraints=()</em>, <em class="sig-param">tol=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">options=None</em>, <em class="sig-param">evolution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.Optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>evolution</strong></dt><dd></dd>
<dt><strong>fopt</strong></dt><dd></dd>
<dt><strong>message</strong></dt><dd></dd>
<dt><strong>nfev</strong></dt><dd></dd>
<dt><strong>nit</strong></dt><dd></dd>
<dt><strong>xopt</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>print_summary</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.streamlinear.Optimizer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">fun</em>, <em class="sig-param">x0</em>, <em class="sig-param">args=()</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">jac=None</em>, <em class="sig-param">hess=None</em>, <em class="sig-param">hessp=None</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">constraints=()</em>, <em class="sig-param">tol=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">options=None</em>, <em class="sig-param">evolution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.Optimizer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for handling minimization of scalar function of one or more
variables.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>fun</strong><span class="classifier">callable</span></dt><dd><p>Objective function.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">ndarray</span></dt><dd><p>Initial guess.</p>
</dd>
<dt><strong>args</strong><span class="classifier">tuple, optional</span></dt><dd><p>Extra arguments passed to the objective function and its
derivatives (Jacobian, Hessian).</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>Type of solver.  Should be one of</p>
<blockquote>
<div><ul class="simple">
<li><p>‘Nelder-Mead’</p></li>
<li><p>‘Powell’</p></li>
<li><p>‘CG’</p></li>
<li><p>‘BFGS’</p></li>
<li><p>‘Newton-CG’</p></li>
<li><p>‘Anneal’</p></li>
<li><p>‘L-BFGS-B’</p></li>
<li><p>‘TNC’</p></li>
<li><p>‘COBYLA’</p></li>
<li><p>‘SLSQP’</p></li>
<li><p>‘dogleg’</p></li>
<li><p>‘trust-ncg’</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>jac</strong><span class="classifier">bool or callable, optional</span></dt><dd><p>Jacobian of objective function. Only for CG, BFGS, Newton-CG,
dogleg, trust-ncg.
If <cite>jac</cite> is a Boolean and is True, <cite>fun</cite> is assumed to return the
value of Jacobian along with the objective function. If False, the
Jacobian will be estimated numerically.
<cite>jac</cite> can also be a callable returning the Jacobian of the
objective. In this case, it must accept the same arguments
as <cite>fun</cite>.</p>
</dd>
<dt><strong>hess, hessp</strong><span class="classifier">callable, optional</span></dt><dd><p>Hessian of objective function or Hessian of objective function
times an arbitrary vector p.  Only for Newton-CG,
dogleg, trust-ncg.
Only one of <cite>hessp</cite> or <cite>hess</cite> needs to be given.  If <cite>hess</cite> is
provided, then <cite>hessp</cite> will be ignored.  If neither <cite>hess</cite> nor
<cite>hessp</cite> is provided, then the hessian product will be approximated
using finite differences on <cite>jac</cite>. <cite>hessp</cite> must compute the Hessian
times an arbitrary vector.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">sequence, optional</span></dt><dd><p>Bounds for variables (only for L-BFGS-B, TNC and SLSQP).
<code class="docutils literal notranslate"><span class="pre">(min,</span> <span class="pre">max)</span></code> pairs for each element in <code class="docutils literal notranslate"><span class="pre">x</span></code>, defining
the bounds on that parameter. Use None for one of <code class="docutils literal notranslate"><span class="pre">min</span></code> or
<code class="docutils literal notranslate"><span class="pre">max</span></code> when there is no bound in that direction.</p>
</dd>
<dt><strong>constraints</strong><span class="classifier">dict or sequence of dict, optional</span></dt><dd><p>Constraints definition (only for COBYLA and SLSQP).
Each constraint is defined in a dictionary with fields:</p>
<blockquote>
<div><dl class="simple">
<dt>type<span class="classifier">str</span></dt><dd><p>Constraint type: ‘eq’ for equality, ‘ineq’ for inequality.</p>
</dd>
<dt>fun<span class="classifier">callable</span></dt><dd><p>The function defining the constraint.</p>
</dd>
<dt>jac<span class="classifier">callable, optional</span></dt><dd><p>The Jacobian of <cite>fun</cite> (only for SLSQP).</p>
</dd>
<dt>args<span class="classifier">sequence, optional</span></dt><dd><p>Extra arguments to be passed to the function and Jacobian.</p>
</dd>
</dl>
</div></blockquote>
<p>Equality constraint means that the constraint function result is to
be zero whereas inequality means that it is to be non-negative.
Note that COBYLA only supports inequality constraints.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance for termination. For detailed control, use
solver-specific options.</p>
</dd>
<dt><strong>callback</strong><span class="classifier">callable, optional</span></dt><dd><p>Called after each iteration, as <code class="docutils literal notranslate"><span class="pre">callback(xk)</span></code>, where <code class="docutils literal notranslate"><span class="pre">xk</span></code> is
the current parameter vector. Only available using Scipy &gt;= 0.12.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>A dictionary of solver options. All methods accept the following
generic options:</p>
<blockquote>
<div><dl class="simple">
<dt>maxiter<span class="classifier">int</span></dt><dd><p>Maximum number of iterations to perform.</p>
</dd>
<dt>disp<span class="classifier">bool</span></dt><dd><p>Set to True to print convergence messages.</p>
</dd>
</dl>
</div></blockquote>
<p>For method-specific options, see
<cite>show_options(‘minimize’, method)</cite>.</p>
</dd>
<dt><strong>evolution</strong><span class="classifier">bool, optional</span></dt><dd><p>save history of x for each iteration. Only available using Scipy
&gt;= 0.12.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.Optimizer.evolution">
<em class="property">property </em><code class="sig-name descname">evolution</code><a class="headerlink" href="#dipy.align.streamlinear.Optimizer.evolution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.Optimizer.fopt">
<em class="property">property </em><code class="sig-name descname">fopt</code><a class="headerlink" href="#dipy.align.streamlinear.Optimizer.fopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.Optimizer.message">
<em class="property">property </em><code class="sig-name descname">message</code><a class="headerlink" href="#dipy.align.streamlinear.Optimizer.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.Optimizer.nfev">
<em class="property">property </em><code class="sig-name descname">nfev</code><a class="headerlink" href="#dipy.align.streamlinear.Optimizer.nfev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.Optimizer.nit">
<em class="property">property </em><code class="sig-name descname">nit</code><a class="headerlink" href="#dipy.align.streamlinear.Optimizer.nit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.Optimizer.print_summary">
<code class="sig-name descname">print_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.Optimizer.print_summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.Optimizer.xopt">
<em class="property">property </em><code class="sig-name descname">xopt</code><a class="headerlink" href="#dipy.align.streamlinear.Optimizer.xopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="streamlinedistancemetric">
<h3><a class="reference internal" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="dipy.align.streamlinear.StreamlineDistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineDistanceMetric</span></code></a><a class="headerlink" href="#streamlinedistancemetric" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.streamlinear.StreamlineDistanceMetric">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">StreamlineDistanceMetric</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineDistanceMetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.StreamlineDistanceMetric.distance" title="dipy.align.streamlinear.StreamlineDistanceMetric.distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code></a>(xopt)</p></td>
<td><p>calculate distance for current set of parameters</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 53%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>setup</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.streamlinear.StreamlineDistanceMetric.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineDistanceMetric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for the metric used for streamline registration</p>
<p>If the two sets of streamlines match exactly then method <code class="docutils literal notranslate"><span class="pre">distance</span></code>
of this object should be minimum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.StreamlineDistanceMetric.distance">
<em class="property">abstract </em><code class="sig-name descname">distance</code><span class="sig-paren">(</span><em class="sig-param">xopt</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineDistanceMetric.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate distance for current set of parameters</p>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.StreamlineDistanceMetric.setup">
<em class="property">abstract </em><code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">moving</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineDistanceMetric.setup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="streamlinelinearregistration">
<h3><a class="reference internal" href="#dipy.align.streamlinear.StreamlineLinearRegistration" title="dipy.align.streamlinear.StreamlineLinearRegistration"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineLinearRegistration</span></code></a><a class="headerlink" href="#streamlinelinearregistration" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.streamlinear.StreamlineLinearRegistration">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">StreamlineLinearRegistration</code><span class="sig-paren">(</span><em class="sig-param">metric=None</em>, <em class="sig-param">x0='rigid'</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">options=None</em>, <em class="sig-param">evolution=False</em>, <em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineLinearRegistration" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.StreamlineLinearRegistration.optimize" title="dipy.align.streamlinear.StreamlineLinearRegistration.optimize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize</span></code></a>(static, moving[, mat])</p></td>
<td><p>Find the minimum of the provided metric.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.streamlinear.StreamlineLinearRegistration.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">metric=None</em>, <em class="sig-param">x0='rigid'</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">options=None</em>, <em class="sig-param">evolution=False</em>, <em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineLinearRegistration.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear registration of 2 sets of streamlines <a class="reference internal" href="#re074e0214f5e-garyfallidis15" id="id16">[Garyfallidis15]</a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>metric</strong><span class="classifier">StreamlineDistanceMetric,</span></dt><dd><p>If None and fast is False then the BMD distance is used. If fast
is True then a faster implementation of BMD is used. Otherwise,
use the given distance metric.</p>
</dd>
<dt><strong>x0</strong><span class="classifier">array or int or str</span></dt><dd><p>Initial parametrization for the optimization.</p>
<dl>
<dt>If 1D array with:</dt><dd><p>a) 6 elements then only rigid registration is performed with
the 3 first elements for translation and 3 for rotation.
b) 7 elements also isotropic scaling is performed (similarity).
c) 12 elements then translation, rotation (in degrees),
scaling and shearing is performed (affine).</p>
<p>Here is an example of x0 with 12 elements:
<code class="docutils literal notranslate"><span class="pre">x0=np.array([0,</span> <span class="pre">10,</span> <span class="pre">0,</span> <span class="pre">40,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">2.,</span> <span class="pre">1.5,</span> <span class="pre">1,</span> <span class="pre">0.1,</span> <span class="pre">-0.5,</span> <span class="pre">0])</span></code></p>
<p>This has translation (0, 10, 0), rotation (40, 0, 0) in
degrees, scaling (2., 1.5, 1) and shearing (0.1, -0.5, 0).</p>
</dd>
<dt>If int:</dt><dd><ol class="loweralpha simple">
<li><dl class="simple">
<dt>6</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>7</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>12</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
</ol>
</dd>
<dt>If str:</dt><dd><ol class="loweralpha simple">
<li><dl class="simple">
<dt>“rigid”</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“similarity”</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.])</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“affine”</dt><dd><p><code class="docutils literal notranslate"><span class="pre">x0</span> <span class="pre">=</span> <span class="pre">np.array([0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1.,</span> <span class="pre">1.,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0])</span></code></p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
</dd>
<dt><strong>method</strong><span class="classifier">str,</span></dt><dd><p>‘L_BFGS_B’ or ‘Powell’ optimizers can be used. Default is
‘L_BFGS_B’.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">list of tuples or None,</span></dt><dd><p>If method == ‘L_BFGS_B’ then we can use bounded optimization.
For example for the six parameters of rigid rotation we can set
the bounds = [(-30, 30), (-30, 30), (-30, 30),</p>
<blockquote>
<div><p>(-45, 45), (-45, 45), (-45, 45)]</p>
</div></blockquote>
<p>That means that we have set the bounds for the three translations
and three rotation axes (in degrees).</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool,</span></dt><dd><p>If True then information about the optimization is shown.</p>
</dd>
<dt><strong>options</strong><span class="classifier">None or dict,</span></dt><dd><p>Extra options to be used with the selected method.</p>
</dd>
<dt><strong>evolution</strong><span class="classifier">boolean</span></dt><dd><p>If True save the transformation for each iteration of the
optimizer. Default is False. Supported only with Scipy &gt;= 0.11.</p>
</dd>
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re074e0214f5e-garyfallidis15"><span class="brackets">Garyfallidis15</span><span class="fn-backref">(<a href="#id16">1</a>,<a href="#id17">2</a>)</span></dt>
<dd><p>Garyfallidis et al. “Robust and efficient linear
registration of white-matter fascicles in the space of streamlines”,
NeuroImage, 117, 124–140, 2015</p>
</dd>
<dt class="label" id="re074e0214f5e-garyfallidis14"><span class="brackets"><a class="fn-backref" href="#id18">Garyfallidis14</a></span></dt>
<dd><p>Garyfallidis et al., “Direct native-space fiber
bundle alignment for group comparisons”, ISMRM, 2014.</p>
</dd>
<dt class="label" id="re074e0214f5e-garyfallidis17"><span class="brackets"><a class="fn-backref" href="#id19">Garyfallidis17</a></span></dt>
<dd><p>Garyfallidis et al. Recognition of white matter
bundles using local and global streamline-based
registration and clustering, Neuroimage, 2017.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.StreamlineLinearRegistration.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">moving</em>, <em class="sig-param">mat=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineLinearRegistration.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the minimum of the provided metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">streamlines</span></dt><dd><p>Reference or fixed set of streamlines.</p>
</dd>
<dt><strong>moving</strong><span class="classifier">streamlines</span></dt><dd><p>Moving set of streamlines.</p>
</dd>
<dt><strong>mat</strong><span class="classifier">array</span></dt><dd><p>Transformation (4, 4) matrix to start the registration. <code class="docutils literal notranslate"><span class="pre">mat</span></code>
is applied to moving. Default value None which means that initial
transformation will be generated by shifting the centers of moving
and static sets of streamlines to the origin.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>map</strong><span class="classifier">StreamlineRegistrationMap</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="streamlineregistrationmap">
<h3><a class="reference internal" href="#dipy.align.streamlinear.StreamlineRegistrationMap" title="dipy.align.streamlinear.StreamlineRegistrationMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamlineRegistrationMap</span></code></a><a class="headerlink" href="#streamlineregistrationmap" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="dipy.align.streamlinear.StreamlineRegistrationMap">
<em class="property">class </em><code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">StreamlineRegistrationMap</code><span class="sig-paren">(</span><em class="sig-param">matopt</em>, <em class="sig-param">xopt</em>, <em class="sig-param">fopt</em>, <em class="sig-param">matopt_history</em>, <em class="sig-param">funcs</em>, <em class="sig-param">iterations</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineRegistrationMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#dipy.align.streamlinear.StreamlineRegistrationMap.transform" title="dipy.align.streamlinear.StreamlineRegistrationMap.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>(moving)</p></td>
<td><p>Transform moving streamlines to the static.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dipy.align.streamlinear.StreamlineRegistrationMap.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">matopt</em>, <em class="sig-param">xopt</em>, <em class="sig-param">fopt</em>, <em class="sig-param">matopt_history</em>, <em class="sig-param">funcs</em>, <em class="sig-param">iterations</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineRegistrationMap.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A map holding the optimum affine matrix and some other parameters
of the optimization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">array,</span></dt><dd><p>4x4 affine matrix which transforms the moving to the static
streamlines</p>
</dd>
<dt><strong>xopt</strong><span class="classifier">array,</span></dt><dd><p>1d array with the parameters of the transformation after centering</p>
</dd>
<dt><strong>fopt</strong><span class="classifier">float,</span></dt><dd><p>final value of the metric</p>
</dd>
<dt><strong>matrix_history</strong><span class="classifier">array</span></dt><dd><p>All transformation matrices created during the optimization</p>
</dd>
<dt><strong>funcs</strong><span class="classifier">int,</span></dt><dd><p>Number of function evaluations of the optimizer</p>
</dd>
<dt><strong>iterations</strong><span class="classifier">int</span></dt><dd><p>Number of iterations of the optimizer</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dipy.align.streamlinear.StreamlineRegistrationMap.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">moving</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.StreamlineRegistrationMap.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform moving streamlines to the static.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>moving</strong><span class="classifier">streamlines</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>moved</strong><span class="classifier">streamlines</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>All this does is apply <code class="docutils literal notranslate"><span class="pre">self.matrix</span></code> to the input streamlines.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="streamlines">
<h3><a class="reference internal" href="#dipy.align.streamlinear.Streamlines" title="dipy.align.streamlinear.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">Streamlines</span></code></a><a class="headerlink" href="#streamlines" title="Permalink to this headline">¶</a></h3>
<dl class="attribute">
<dt id="dipy.align.streamlinear.Streamlines">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">Streamlines</code><a class="headerlink" href="#dipy.align.streamlinear.Streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.streamlines.array_sequence.ArraySequence</span></code></p>
</dd></dl>

</div>
<div class="section" id="bundle-min-distance">
<h3>bundle_min_distance<a class="headerlink" href="#bundle-min-distance" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.bundle_min_distance">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">bundle_min_distance</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">static</em>, <em class="sig-param">moving</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.bundle_min_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>MDF-based pairwise distance optimization function (MIN)</p>
<p>We minimize the distance between moving streamlines as they align
with the static streamlines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">ndarray</span></dt><dd><p>t is a vector of of affine transformation parameters with
size at least 6.
If size is 6, t is interpreted as translation + rotation.
If size is 7, t is interpreted as translation + rotation +
isotropic scaling.
If size is 12, t is interpreted as translation + rotation +
scaling + shearing.</p>
</dd>
<dt><strong>static</strong><span class="classifier">list</span></dt><dd><p>Static streamlines</p>
</dd>
<dt><strong>moving</strong><span class="classifier">list</span></dt><dd><p>Moving streamlines.</p>
</dd>
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cost: float</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="bundle-min-distance-asymmetric-fast">
<h3>bundle_min_distance_asymmetric_fast<a class="headerlink" href="#bundle-min-distance-asymmetric-fast" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.bundle_min_distance_asymmetric_fast">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">bundle_min_distance_asymmetric_fast</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">static</em>, <em class="sig-param">moving</em>, <em class="sig-param">block_size</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.bundle_min_distance_asymmetric_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>MDF-based pairwise distance optimization function (MIN)</p>
<p>We minimize the distance between moving streamlines as they align
with the static streamlines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">array</span></dt><dd><p>1D array. t is a vector of of affine transformation parameters with
size at least 6.
If size is 6, t is interpreted as translation + rotation.
If size is 7, t is interpreted as translation + rotation +
isotropic scaling.
If size is 12, t is interpreted as translation + rotation +
scaling + shearing.</p>
</dd>
<dt><strong>static</strong><span class="classifier">array</span></dt><dd><p>N*M x 3 array. All the points of the static streamlines. With order of
streamlines intact. Where N is the number of streamlines and M
is the number of points per streamline.</p>
</dd>
<dt><strong>moving</strong><span class="classifier">array</span></dt><dd><p>K*M x 3 array. All the points of the moving streamlines. With order of
streamlines intact. Where K is the number of streamlines and M
is the number of points per streamline.</p>
</dd>
<dt><strong>block_size</strong><span class="classifier">int</span></dt><dd><p>Number of points per streamline. All streamlines in static and moving
should have the same number of points M.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cost: float</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="bundle-min-distance-fast">
<h3>bundle_min_distance_fast<a class="headerlink" href="#bundle-min-distance-fast" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.bundle_min_distance_fast">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">bundle_min_distance_fast</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">static</em>, <em class="sig-param">moving</em>, <em class="sig-param">block_size</em>, <em class="sig-param">num_threads</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.bundle_min_distance_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>MDF-based pairwise distance optimization function (MIN)</p>
<p>We minimize the distance between moving streamlines as they align
with the static streamlines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">array</span></dt><dd><p>1D array. t is a vector of of affine transformation parameters with
size at least 6.
If size is 6, t is interpreted as translation + rotation.
If size is 7, t is interpreted as translation + rotation +
isotropic scaling.
If size is 12, t is interpreted as translation + rotation +
scaling + shearing.</p>
</dd>
<dt><strong>static</strong><span class="classifier">array</span></dt><dd><p>N*M x 3 array. All the points of the static streamlines. With order of
streamlines intact. Where N is the number of streamlines and M
is the number of points per streamline.</p>
</dd>
<dt><strong>moving</strong><span class="classifier">array</span></dt><dd><p>K*M x 3 array. All the points of the moving streamlines. With order of
streamlines intact. Where K is the number of streamlines and M
is the number of points per streamline.</p>
</dd>
<dt><strong>block_size</strong><span class="classifier">int</span></dt><dd><p>Number of points per streamline. All streamlines in static and moving
should have the same number of points M.</p>
</dd>
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cost: float</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is a faster implementation of <code class="docutils literal notranslate"><span class="pre">bundle_min_distance</span></code>, which requires
that all the points of each streamline are allocated into an ndarray
(of shape N*M by 3, with N the number of points per streamline and M the
number of streamlines). This can be done by calling
<cite>dipy.tracking.streamlines.unlist_streamlines</cite>.</p>
</dd></dl>

</div>
<div class="section" id="bundle-sum-distance">
<h3>bundle_sum_distance<a class="headerlink" href="#bundle-sum-distance" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.bundle_sum_distance">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">bundle_sum_distance</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">static</em>, <em class="sig-param">moving</em>, <em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.bundle_sum_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>MDF distance optimization function (SUM)</p>
<p>We minimize the distance between moving streamlines as they align
with the static streamlines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">ndarray</span></dt><dd><p>t is a vector of of affine transformation parameters with
size at least 6.
If size is 6, t is interpreted as translation + rotation.
If size is 7, t is interpreted as translation + rotation +
isotropic scaling.
If size is 12, t is interpreted as translation + rotation +
scaling + shearing.</p>
</dd>
<dt><strong>static</strong><span class="classifier">list</span></dt><dd><p>Static streamlines</p>
</dd>
<dt><strong>moving</strong><span class="classifier">list</span></dt><dd><p>Moving streamlines. These will be transform to align with
the static streamlines</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cost: float</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="center-streamlines">
<h3>center_streamlines<a class="headerlink" href="#center-streamlines" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.center_streamlines">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">center_streamlines</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.center_streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Move streamlines to the origin</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">list</span></dt><dd><p>List of 2D ndarrays of shape[-1]==3</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_streamlines</strong><span class="classifier">list</span></dt><dd><p>List of 2D ndarrays of shape[-1]==3</p>
</dd>
<dt><strong>inv_shift</strong><span class="classifier">ndarray</span></dt><dd><p>Translation in x,y,z to go back in the initial position</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="compose-matrix">
<h3>compose_matrix<a class="headerlink" href="#compose-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.compose_matrix">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">compose_matrix</code><span class="sig-paren">(</span><em class="sig-param">scale=None</em>, <em class="sig-param">shear=None</em>, <em class="sig-param">angles=None</em>, <em class="sig-param">translate=None</em>, <em class="sig-param">perspective=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.compose_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 4x4 transformation matrix from sequence of
transformations.</p>
<p>Code modified from the work of Christoph Gohlke link provided here
<a class="reference external" href="http://www.lfd.uci.edu/~gohlke/code/transformations.py.html">http://www.lfd.uci.edu/~gohlke/code/transformations.py.html</a></p>
<p>This is the inverse of the <code class="docutils literal notranslate"><span class="pre">decompose_matrix</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">(3,) array_like</span></dt><dd><p>Scaling factors.</p>
</dd>
<dt><strong>shear</strong><span class="classifier">array_like</span></dt><dd><p>Shear factors for x-y, x-z, y-z axes.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">array_like</span></dt><dd><p>Euler angles about static x, y, z axes.</p>
</dd>
<dt><strong>translate</strong><span class="classifier">array_like</span></dt><dd><p>Translation vector along x, y, z axes.</p>
</dd>
<dt><strong>perspective</strong><span class="classifier">array_like</span></dt><dd><p>Perspective partition of matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">4x4 array</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dipy.core.geometry</span> <span class="k">as</span> <span class="nn">gm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angles</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">persp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M0</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">compose_matrix</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">persp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="compose-matrix44">
<h3>compose_matrix44<a class="headerlink" href="#compose-matrix44" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.compose_matrix44">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">compose_matrix44</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.compose_matrix44" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose a 4x4 transformation matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">ndarray</span></dt><dd><p>This is a 1D vector of of affine transformation parameters with
size at least 3.
If size is 3, t is interpreted as translation.
If size is 6, t is interpreted as translation + rotation.
If size is 7, t is interpreted as translation + rotation +
isotropic scaling.
If size is 9, t is interpreted as translation + rotation +
anisotropic scaling.
If size is 12, t is interpreted as translation + rotation +
scaling + shearing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>T</strong><span class="classifier">ndarray</span></dt><dd><p>Homogeneous transformation matrix of size 4x4.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="compose-transformations">
<h3>compose_transformations<a class="headerlink" href="#compose-transformations" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.compose_transformations">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">compose_transformations</code><span class="sig-paren">(</span><em class="sig-param">*mats</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.compose_transformations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose multiple 4x4 affine transformations in one 4x4 matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mat1</strong><span class="classifier">array, (4, 4)</span></dt><dd></dd>
<dt><strong>mat2</strong><span class="classifier">array, (4, 4)</span></dt><dd></dd>
<dt><strong>…</strong></dt><dd></dd>
<dt><strong>matN</strong><span class="classifier">array, (4, 4)</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matN x … x mat2 x mat1</strong><span class="classifier">array, (4, 4)</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="decompose-matrix">
<h3>decompose_matrix<a class="headerlink" href="#decompose-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.decompose_matrix">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">decompose_matrix</code><span class="sig-paren">(</span><em class="sig-param">matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.decompose_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sequence of transformations from transformation matrix.</p>
<p>Code modified from the excellent work of Christoph Gohlke link provided
here: <a class="reference external" href="http://www.lfd.uci.edu/~gohlke/code/transformations.py.html">http://www.lfd.uci.edu/~gohlke/code/transformations.py.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">array_like</span></dt><dd><p>Non-degenerative homogeneous transformation matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>Three scaling factors.</p>
</dd>
<dt><strong>shear</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>Shear factors for x-y, x-z, y-z axes.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>Euler angles about static x, y, z axes.</p>
</dd>
<dt><strong>translate</strong><span class="classifier">(3,) ndarray</span></dt><dd><p>Translation vector along x, y, z axes.</p>
</dd>
<dt><strong>perspective</strong><span class="classifier">ndarray</span></dt><dd><p>Perspective partition of matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If matrix is of wrong type or degenerative.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">persp</span> <span class="o">=</span> <span class="n">decompose_matrix</span><span class="p">(</span><span class="n">T0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="decompose-matrix44">
<h3>decompose_matrix44<a class="headerlink" href="#decompose-matrix44" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.decompose_matrix44">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">decompose_matrix44</code><span class="sig-paren">(</span><em class="sig-param">mat</em>, <em class="sig-param">size=12</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.decompose_matrix44" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a 4x4 homogeneous matrix return the parameter vector</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mat</strong><span class="classifier">array</span></dt><dd><p>Homogeneous 4x4 transformation matrix</p>
</dd>
<dt><strong>size</strong><span class="classifier">int</span></dt><dd><p>Size of output vector. 3, for translation, 6 for rigid,
7 for similarity, 9 for scaling and 12 for affine. Default is 12.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>t</strong><span class="classifier">ndarray</span></dt><dd><p>One dimensional ndarray of 3, 6, 7, 9 or 12 affine parameters.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="distance-matrix-mdf">
<h3>distance_matrix_mdf<a class="headerlink" href="#distance-matrix-mdf" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.distance_matrix_mdf">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">distance_matrix_mdf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.distance_matrix_mdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum direct flipped distance matrix between two streamline sets</p>
<p>All streamlines need to have the same number of points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines_a</strong><span class="classifier">sequence</span></dt><dd><p>of streamlines as arrays, [(N, 3) .. (N, 3)]</p>
</dd>
<dt><strong>streamlines_b</strong><span class="classifier">sequence</span></dt><dd><p>of streamlines as arrays, [(N, 3) .. (N, 3)]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DM</strong><span class="classifier">array, shape (len(streamlines_a), len(streamlines_b))</span></dt><dd><p>distance matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="length">
<h3>length<a class="headerlink" href="#length" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.length">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Euclidean length of streamlines</p>
<p>Length is in mm only if streamlines are expressed in world coordinates.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>streamlines</strong><span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>If ndarray, must have shape (N,3) where N is the number of points
of the streamline.
If list, each item must be ndarray shape (Ni,3) where Ni is the number
of points of streamline i.
If <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a>, its <cite>common_shape</cite> must be 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lengths</strong><span class="classifier">scalar or ndarray shape (N,)</span></dt><dd><p>If there is only one streamline, a scalar representing the length of the
streamline.
If there are several streamlines, ndarray containing the length of every
streamline.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.tracking.streamline</span> <span class="k">import</span> <span class="n">length</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expected_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="o">**</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span><span class="p">(</span><span class="n">streamline</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected_length</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamlines</span> <span class="o">=</span> <span class="p">[</span><span class="n">streamline</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">streamline</span><span class="p">,</span> <span class="n">streamline</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expected_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">expected_length</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">expected_length</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">length</span><span class="p">(</span><span class="n">streamlines</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">length</span><span class="p">(</span><span class="n">streamlines</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">expected_lengths</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span><span class="p">([])</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]))</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="progressive-slr">
<h3>progressive_slr<a class="headerlink" href="#progressive-slr" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.progressive_slr">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">progressive_slr</code><span class="sig-paren">(</span><em class="sig-param">static</em>, <em class="sig-param">moving</em>, <em class="sig-param">metric</em>, <em class="sig-param">x0</em>, <em class="sig-param">bounds</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">verbose=True</em>, <em class="sig-param">num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.progressive_slr" title="Permalink to this definition">¶</a></dt>
<dd><p>Progressive SLR</p>
<p>This is an utility function that allows for example to do affine
registration using Streamline-based Linear Registration (SLR)
<a class="reference internal" href="#rf35afc261ac1-garyfallidis15" id="id20">[Garyfallidis15]</a> by starting with translation first, then rigid,
then similarity, scaling and finally affine.</p>
<p>Similarly, if for example you want to perform rigid then you start with
translation first. This progressive strategy can helps with finding the
optimal parameters of the final transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>moving</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>metric</strong><span class="classifier">StreamlineDistanceMetric</span></dt><dd></dd>
<dt><strong>x0</strong><span class="classifier">string</span></dt><dd><p>Could be any of ‘translation’, ‘rigid’, ‘similarity’, ‘scaling’,
‘affine’</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">array</span></dt><dd><p>Boundaries of registration parameters. See variable <cite>DEFAULT_BOUNDS</cite>
for example.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string</span></dt><dd><p>L_BFGS_B’ or ‘Powell’ optimizers can be used. Default is ‘L_BFGS_B’.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True show messages in stdout (default True).</p>
</dd>
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf35afc261ac1-garyfallidis15"><span class="brackets">Garyfallidis15</span><span class="fn-backref">(<a href="#id20">1</a>,<a href="#id21">2</a>)</span></dt>
<dd><p>Garyfallidis et al. “Robust and efficient linear
registration of white-matter fascicles in the space of streamlines”,
NeuroImage, 117, 124–140, 2015</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="qbx-and-merge">
<h3>qbx_and_merge<a class="headerlink" href="#qbx-and-merge" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.qbx_and_merge">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">qbx_and_merge</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em>, <em class="sig-param">thresholds</em>, <em class="sig-param">nb_pts=20</em>, <em class="sig-param">select_randomly=None</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.qbx_and_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Run QuickBundlesX and then run again on the centroids of the last layer</p>
<p>Running again QuickBundles at a layer has the effect of merging
some of the clusters that maybe originally devided because of branching.
This function help obtain a result at a QuickBundles quality but with
QuickBundlesX speed. The merging phase has low cost because it is applied
only on the centroids rather than the entire dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>thresholds</strong><span class="classifier">sequence</span></dt><dd><p>List of distance thresholds for QuickBundlesX.</p>
</dd>
<dt><strong>nb_pts</strong><span class="classifier">int</span></dt><dd><p>Number of points for discretizing each streamline</p>
</dd>
<dt><strong>select_randomly</strong><span class="classifier">int</span></dt><dd><p>Randomly select a specific number of streamlines. If None all the
streamlines are used.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">RandomState</span></dt><dd><p>If None then RandomState is initialized internally.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>If True print information in stdout.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>clusters</strong><span class="classifier">obj</span></dt><dd><p>Contains the clusters of the last layer of QuickBundlesX after merging.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4b468f33dacd-garyfallidis12"><span class="brackets"><a class="fn-backref" href="#id22">Garyfallidis12</a></span></dt>
<dd><p>Garyfallidis E. et al., QuickBundles a method for
tractography simplification, Frontiers in Neuroscience,
vol 6, no 175, 2012.</p>
</dd>
<dt class="label" id="r4b468f33dacd-garyfallidis16"><span class="brackets"><a class="fn-backref" href="#id23">Garyfallidis16</a></span></dt>
<dd><p>Garyfallidis E. et al. QuickBundlesX: Sequential
clustering of millions of streamlines in multiple
levels of detail at record execution time. Proceedings
of the, International Society of Magnetic Resonance
in Medicine (ISMRM). Singapore, 4187, 2016.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="remove-clusters-by-size">
<h3>remove_clusters_by_size<a class="headerlink" href="#remove-clusters-by-size" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.remove_clusters_by_size">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">remove_clusters_by_size</code><span class="sig-paren">(</span><em class="sig-param">clusters</em>, <em class="sig-param">min_size=0</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.remove_clusters_by_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="select-random-set-of-streamlines">
<h3>select_random_set_of_streamlines<a class="headerlink" href="#select-random-set-of-streamlines" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.select_random_set_of_streamlines">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">select_random_set_of_streamlines</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em>, <em class="sig-param">select</em>, <em class="sig-param">rng=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.select_random_set_of_streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a random set of streamlines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">Steamlines</span></dt><dd><p>Object of 2D ndarrays of shape[-1]==3</p>
</dd>
<dt><strong>select</strong><span class="classifier">int</span></dt><dd><p>Number of streamlines to select. If there are less streamlines
than <code class="docutils literal notranslate"><span class="pre">select</span></code> then <code class="docutils literal notranslate"><span class="pre">select=len(streamlines)</span></code>.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">RandomState</span></dt><dd><p>Default None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selected_streamlines</strong><span class="classifier">list</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The same streamline will not be selected twice.</p>
</dd></dl>

</div>
<div class="section" id="set-number-of-points">
<h3>set_number_of_points<a class="headerlink" href="#set-number-of-points" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.set_number_of_points">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">set_number_of_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.set_number_of_points" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Change the number of points of streamlines</dt><dd><p>(either by downsampling or upsampling)</p>
</dd>
</dl>
<p>Change the number of points of streamlines in order to obtain
<cite>nb_points</cite>-1 segments of equal length. Points of streamlines will be
modified along the curve.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>streamlines</strong><span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>If ndarray, must have shape (N,3) where N is the number of points
of the streamline.
If list, each item must be ndarray shape (Ni,3) where Ni is the number
of points of streamline i.
If <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a>, its <cite>common_shape</cite> must be 3.</p>
</dd>
<dt><strong>nb_points</strong><span class="classifier">int</span></dt><dd><p>integer representing number of points wanted along the curve.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>new_streamlines</strong><span class="classifier">ndarray or a list or <a class="reference internal" href="dipy.tracking.html#dipy.tracking.Streamlines" title="dipy.tracking.Streamlines"><code class="xref py py-class docutils literal notranslate"><span class="pre">dipy.tracking.Streamlines</span></code></a></span></dt><dd><p>Results of the downsampling or upsampling process.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dipy.tracking.streamline</span> <span class="k">import</span> <span class="n">set_number_of_points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>One streamline, a semi-circle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">modified_streamline</span> <span class="o">=</span> <span class="n">set_number_of_points</span><span class="p">(</span><span class="n">streamline</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">modified_streamline</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Multiple streamlines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">streamlines</span> <span class="o">=</span> <span class="p">[</span><span class="n">streamline</span><span class="p">,</span> <span class="n">streamline</span><span class="p">[::</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_streamlines</span> <span class="o">=</span> <span class="n">set_number_of_points</span><span class="p">(</span><span class="n">streamlines</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">streamlines</span><span class="p">]</span>
<span class="go">[100, 50]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_streamlines</span><span class="p">]</span>
<span class="go">[10, 10]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="slr-with-qbx">
<h3>slr_with_qbx<a class="headerlink" href="#slr-with-qbx" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.slr_with_qbx">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">slr_with_qbx</code><span class="sig-paren">(</span><em class="sig-param">static, moving, x0='affine', rm_small_clusters=50, maxiter=100, select_random=None, verbose=False, greater_than=50, less_than=250, qbx_thr=[40, 30, 20, 15], nb_pts=20, progressive=True, rng=None, num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.slr_with_qbx" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function for registering large tractograms.</p>
<p>For efficiency we apply the registration on cluster centroids and remove
small clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>moving</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>x0</strong><span class="classifier">str</span></dt><dd><p>rigid, similarity or affine transformation model (default affine)</p>
</dd>
<dt><strong>rm_small_clusters</strong><span class="classifier">int</span></dt><dd><p>Remove clusters that have less than <cite>rm_small_clusters</cite> (default 50)</p>
</dd>
<dt><strong>select_random</strong><span class="classifier">int</span></dt><dd><p>If not None select a random number of streamlines to apply clustering
Default None.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool,</span></dt><dd><p>If True then information about the optimization is shown.</p>
</dd>
<dt><strong>greater_than</strong><span class="classifier">int, optional</span></dt><dd><p>Keep streamlines that have length greater than
this value (default 50)</p>
</dd>
<dt><strong>less_than</strong><span class="classifier">int, optional</span></dt><dd><p>Keep streamlines have length less than this value (default 250)</p>
</dd>
<dt><strong>qbx_thr</strong><span class="classifier">variable int</span></dt><dd><p>Thresholds for QuickBundlesX (default [40, 30, 20, 15])</p>
</dd>
<dt><strong>np_pts</strong><span class="classifier">int, optional</span></dt><dd><p>Number of points for discretizing each streamline (default 20)</p>
</dd>
<dt><strong>progressive</strong><span class="classifier">boolean, optional</span></dt><dd><p>(default True)</p>
</dd>
<dt><strong>rng</strong><span class="classifier">RandomState</span></dt><dd><p>If None creates RandomState in function.</p>
</dd>
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The order of operations is the following. First short or long streamlines
are removed. Second the tractogram or a random selection of the tractogram
is clustered with QuickBundles. Then SLR <a class="reference internal" href="#r778a6c20f622-garyfallidis15" id="id24">[Garyfallidis15]</a> is applied.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r778a6c20f622-garyfallidis15"><span class="brackets">Garyfallidis15</span><span class="fn-backref">(<a href="#id24">1</a>,<a href="#id25">2</a>)</span></dt>
<dd><p>Garyfallidis et al. “Robust and efficient linear</p>
</dd>
</dl>
<p>registration of white-matter fascicles in the space of streamlines”,
NeuroImage, 117, 124–140, 2015
.. [R778a6c20f622-Garyfallidis14] Garyfallidis et al., “Direct native-space fiber</p>
<blockquote>
<div><p>bundle alignment for group comparisons”, ISMRM, 2014.</p>
</div></blockquote>
<dl class="citation">
<dt class="label" id="r778a6c20f622-garyfallidis17"><span class="brackets"><a class="fn-backref" href="#id27">Garyfallidis17</a></span></dt>
<dd><p>Garyfallidis et al. Recognition of white matter</p>
</dd>
</dl>
<p>bundles using local and global streamline-based registration and
clustering, Neuroimage, 2017.</p>
</dd></dl>

</div>
<div class="section" id="time">
<h3>time<a class="headerlink" href="#time" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.time">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">time</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; floating point number<a class="headerlink" href="#dipy.align.streamlinear.time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current time in seconds since the Epoch.
Fractions of a second may be present if the system clock provides them.</p>
</dd></dl>

</div>
<div class="section" id="transform-streamlines">
<h3>transform_streamlines<a class="headerlink" href="#transform-streamlines" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.transform_streamlines">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">transform_streamlines</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em>, <em class="sig-param">mat</em>, <em class="sig-param">in_place=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.transform_streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply affine transformation to streamlines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines</strong><span class="classifier">Streamlines</span></dt><dd><p>Streamlines object</p>
</dd>
<dt><strong>mat</strong><span class="classifier">array, (4, 4)</span></dt><dd><p>transformation matrix</p>
</dd>
<dt><strong>in_place</strong><span class="classifier">bool</span></dt><dd><p>If True then change data in place.
Be careful changes input streamlines.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_streamlines</strong><span class="classifier">Streamlines</span></dt><dd><p>Sequence transformed 2D ndarrays of shape[-1]==3</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="unlist-streamlines">
<h3>unlist_streamlines<a class="headerlink" href="#unlist-streamlines" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.unlist_streamlines">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">unlist_streamlines</code><span class="sig-paren">(</span><em class="sig-param">streamlines</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.unlist_streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the streamlines not as a list but as an array and an offset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>streamlines: sequence</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points</strong><span class="classifier">array</span></dt><dd></dd>
<dt><strong>offsets</strong><span class="classifier">array</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="whole-brain-slr">
<h3>whole_brain_slr<a class="headerlink" href="#whole-brain-slr" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="dipy.align.streamlinear.whole_brain_slr">
<code class="sig-prename descclassname">dipy.align.streamlinear.</code><code class="sig-name descname">whole_brain_slr</code><span class="sig-paren">(</span><em class="sig-param">static, moving, x0='affine', rm_small_clusters=50, maxiter=100, select_random=None, verbose=False, greater_than=50, less_than=250, qbx_thr=[40, 30, 20, 15], nb_pts=20, progressive=True, rng=None, num_threads=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dipy.align.streamlinear.whole_brain_slr" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function for registering large tractograms.</p>
<p>For efficiency we apply the registration on cluster centroids and remove
small clusters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>static</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>moving</strong><span class="classifier">Streamlines</span></dt><dd></dd>
<dt><strong>x0</strong><span class="classifier">str</span></dt><dd><p>rigid, similarity or affine transformation model (default affine)</p>
</dd>
<dt><strong>rm_small_clusters</strong><span class="classifier">int</span></dt><dd><p>Remove clusters that have less than <cite>rm_small_clusters</cite> (default 50)</p>
</dd>
<dt><strong>select_random</strong><span class="classifier">int</span></dt><dd><p>If not None select a random number of streamlines to apply clustering
Default None.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool,</span></dt><dd><p>If True then information about the optimization is shown.</p>
</dd>
<dt><strong>greater_than</strong><span class="classifier">int, optional</span></dt><dd><p>Keep streamlines that have length greater than
this value (default 50)</p>
</dd>
<dt><strong>less_than</strong><span class="classifier">int, optional</span></dt><dd><p>Keep streamlines have length less than this value (default 250)</p>
</dd>
<dt><strong>qbx_thr</strong><span class="classifier">variable int</span></dt><dd><p>Thresholds for QuickBundlesX (default [40, 30, 20, 15])</p>
</dd>
<dt><strong>np_pts</strong><span class="classifier">int, optional</span></dt><dd><p>Number of points for discretizing each streamline (default 20)</p>
</dd>
<dt><strong>progressive</strong><span class="classifier">boolean, optional</span></dt><dd><p>(default True)</p>
</dd>
<dt><strong>rng</strong><span class="classifier">RandomState</span></dt><dd><p>If None creates RandomState in function.</p>
</dd>
<dt><strong>num_threads</strong><span class="classifier">int</span></dt><dd><p>Number of threads. If None (default) then all available threads
will be used. Only metrics using OpenMP will use this variable.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The order of operations is the following. First short or long streamlines
are removed. Second the tractogram or a random selection of the tractogram
is clustered with QuickBundles. Then SLR <a class="reference internal" href="#r9eb8c2315518-garyfallidis15" id="id28">[Garyfallidis15]</a> is applied.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9eb8c2315518-garyfallidis15"><span class="brackets">Garyfallidis15</span><span class="fn-backref">(<a href="#id28">1</a>,<a href="#id29">2</a>)</span></dt>
<dd><p>Garyfallidis et al. “Robust and efficient linear</p>
</dd>
</dl>
<p>registration of white-matter fascicles in the space of streamlines”,
NeuroImage, 117, 124–140, 2015
.. [R9eb8c2315518-Garyfallidis14] Garyfallidis et al., “Direct native-space fiber</p>
<blockquote>
<div><p>bundle alignment for group comparisons”, ISMRM, 2014.</p>
</div></blockquote>
<dl class="citation">
<dt class="label" id="r9eb8c2315518-garyfallidis17"><span class="brackets"><a class="fn-backref" href="#id31">Garyfallidis17</a></span></dt>
<dd><p>Garyfallidis et al. Recognition of white matter</p>
</dd>
</dl>
<p>bundles using local and global streamline-based registration and
clustering, Neuroimage, 2017.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dipy.boots.html" title="boots"
             >next</a> |</li>
        <li class="right" >
          <a href="dipy.__config__.html" title="__config__"
             >previous</a> |</li>
  <li><a href="../index.html">Home</a> |&nbsp;</li>
  <li><a href="../stateoftheart.html">Overview</a> |&nbsp;</li>
  <li><a href="../examples_index.html">Gallery</a> |&nbsp;</li>
  <li><a href="../installation.html">Download</a> |&nbsp;</li>
  <li><a href="../subscribe.html">Subscribe</a> |&nbsp;</li>
  <li><a href="../developers.html">Developers</a> |&nbsp;</li>
  <li><a href="../cite.html">Cite</a> &nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >API Reference</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2019, dipy developers &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>